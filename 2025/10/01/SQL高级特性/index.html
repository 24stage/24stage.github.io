<!DOCTYPE html>


<html lang="zh-hans">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="24stage Blog" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>SQL高级特性 |  24stage</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/smile.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-SQL高级特性"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  SQL高级特性
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/10/01/SQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" class="article-date">
  <time datetime="2025-10-01T14:17:05.000Z" itemprop="datePublished">2025-10-01</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">3.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">11 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="视图-VIEW"><a href="#视图-VIEW" class="headerlink" title="视图(VIEW)"></a>视图(VIEW)</h1><p>视图（View）是基于 SQL 查询结果创建的虚拟表，本身不存储数据，而是保存一条 SQL 查询定义。  </p>
<ul>
<li>当访问视图时，数据库会执行定义视图的查询，并返回结果。  </li>
<li><strong>用途</strong>：  <ul>
<li>简化复杂 SQL 查询，提高可读性。  </li>
<li>对用户隐藏表结构，起到安全隔离作用。  </li>
<li>可用于权限控制，限制用户访问数据的范围。</li>
</ul>
</li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> high_salary <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">10000</span>;</span><br></pre></td></tr></table></figure>
使用时：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> high_salary;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是所有数据库系统的基础概念。事务最重要的一点是它将多个步骤捆绑成了一个单一的、要么全完成要么全不完成的操作。步骤之间的中间状态对于其他并发事务是不可见的，并且如果有某些错误发生导致事务不能完成，则其中任何一个步骤都不会对数据库造成影响。</p>
<h3 id="事务与-ACID"><a href="#事务与-ACID" class="headerlink" title="事务与 ACID"></a>事务与 ACID</h3><ul>
<li><strong>原子性（Atomicity）</strong>：事务内的所有操作要么全部成功（COMMIT），要么全部撤销（ROLLBACK）。  </li>
<li><strong>一致性（Consistency）</strong>：事务结束时，数据库从一个一致状态转到另一个一致状态（例如外键、约束未被破坏）。  </li>
<li><strong>隔离性（Isolation）</strong>：并发事务之间互不干扰；一个事务在提交前的中间修改对其他事务不可见，避免脏读、不可重复读、幻读等问题。</li>
<li><strong>持久性（Durability）</strong>：一旦事务提交，修改被持久保存（WAL 日志保证）。</li>
</ul>
<h3 id="基本事务控制语句（PostgreSQL）"><a href="#基本事务控制语句（PostgreSQL）" class="headerlink" title="基本事务控制语句（PostgreSQL）"></a>基本事务控制语句（PostgreSQL）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显式事务块</span></span><br><span class="line"><span class="keyword">BEGIN</span>;           <span class="comment">-- 或 START TRANSACTION;</span></span><br><span class="line">  <span class="comment">-- 若干 DML/DDL/查询</span></span><br><span class="line"><span class="keyword">COMMIT</span>;          <span class="comment">-- 提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果要撤销</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 保存点</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> sp1;</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> sp1;</span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> sp1;</span><br></pre></td></tr></table></figure>

<h3 id="自动提交（Autocommit）"><a href="#自动提交（Autocommit）" class="headerlink" title="自动提交（Autocommit）"></a>自动提交（Autocommit）</h3><ul>
<li>PostgreSQL 默认 <strong>自动提交</strong> 模式：如果不显式使用 BEGIN，数据库会把每条独立语句当作一个隐式事务执行（成功则立即提交）。</li>
</ul>
<h3 id="隔离级别与并发现象"><a href="#隔离级别与并发现象" class="headerlink" title="隔离级别与并发现象"></a>隔离级别与并发现象</h3><p>PostgreSQL 支持标准的隔离级别（但实际 READ UNCOMMITTED 被视作 READ COMMITTED）：</p>
<ol>
<li><p><strong>READ COMMITTED（默认）</strong>  </p>
<ul>
<li>每个语句只能看到其他事务已提交的更改。  </li>
<li>可能发生“不可重复读”（同一事务内相同查询得到不同结果）。</li>
</ul>
</li>
<li><p><strong>REPEATABLE READ</strong>  </p>
<ul>
<li>事务范围内的相同查询返回一致结果（解决不可重复读）；仍可能出现幻读</li>
</ul>
</li>
<li><p><strong>SERIALIZABLE</strong>  </p>
<ul>
<li>最严格的隔离级别，保证结果等价于某种串行执行（可能导致事务冲突并回滚）。</li>
</ul>
</li>
</ol>
<blockquote>
<p>注：PostgreSQL 的具体并发现象与隔离级别实现细节相对复杂，建议在生产场景选择合适隔离级别并通过测试验证。</p>
</blockquote>
<h1 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC(多版本并发控制)"></a>MVCC(多版本并发控制)</h1><p>简单说，它让多个事务可以同时访问同一张表的数据，<br>而又互不干扰、互不锁表。</p>
<p>传统的并发控制方式是加锁（Locking）：<br>当一个事务正在修改某行数据时，其他事务必须等待,并发性能差。</p>
<p><strong>而 MVCC 不加锁读取数据：</strong></p>
<ul>
<li>读操作读取“历史快照（snapshot）”，不阻塞写；</li>
<li>写操作创建“新版本（new version）”，不阻塞读。</li>
</ul>
<blockquote>
<p>✅ 核心思想：数据库中的每一行数据都有多个版本（versions），不同事务可以看到不同版本的数据。</p>
</blockquote>
<h3 id="核心机制："><a href="#核心机制：" class="headerlink" title="核心机制："></a>核心机制：</h3><p>在 PostgreSQL 中，每一行数据（tuple）都包含以下两个隐藏字段：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>xmin</code></td>
<td>插入该行的事务 ID</td>
</tr>
<tr>
<td><code>xmax</code></td>
<td>删除（或更新）该行的事务 ID</td>
</tr>
</tbody></table>
<p>当一个事务读取数据时，它根据自己的“<strong>快照（snapshot）</strong>”决定：</p>
<ul>
<li>哪些版本是可见的；</li>
<li>哪些版本是对自己不可见的（未提交或已删除）。</li>
</ul>
<p><strong>PostgreSQL 的 UPDATE 实际上是 “删除旧行 + 插入新行”；</strong></p>
<p>MVCC 的实现方式总结:</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>动作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SELECT</strong></td>
<td>读取可见版本</td>
<td>不加锁，只看快照</td>
</tr>
<tr>
<td><strong>UPDATE</strong></td>
<td>创建一个新版本（新行）</td>
<td>原版本打上 xmax，表示“过期”</td>
</tr>
<tr>
<td><strong>DELETE</strong></td>
<td>设置 xmax</td>
<td>逻辑删除，不立即物理删除</td>
</tr>
<tr>
<td><strong>VACUUM</strong></td>
<td>清理旧版本</td>
<td>回收空间，防止膨胀</td>
</tr>
</tbody></table>
<h3 id="示例：多版本快照"><a href="#示例：多版本快照" class="headerlink" title="示例：多版本快照"></a>示例：多版本快照</h3><ol>
<li><p>事务 T1 执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Alice&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>系统会：<br>为这行记录生成一个新的版本,设置 <code>xmin = T1</code>, <code>xmax = null（未被删除）</code>；</p>
</li>
<li><p>事务T2 执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> users</span><br><span class="line"><span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;newAlice&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>系统会：更新不是原地修改，而是复制出一行新版本（新 tuple）；<br>旧版本的 xmax 被设为当前事务 ID；<br>新版本的 xmin 被设为当前事务 ID。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>版本</th>
<th>内容</th>
<th>xmin</th>
<th>xmax</th>
</tr>
</thead>
<tbody><tr>
<td>v1</td>
<td>Alice</td>
<td>10 (T1)</td>
<td>20(T2)</td>
</tr>
<tr>
<td>v2</td>
<td>newAlice</td>
<td>20(T2)</td>
<td>null</td>
</tr>
</tbody></table>
<ol start="3">
<li>DELETE<br>删除操作只是在记录上标记 <code>xmax = 当前事务ID</code>，不立即移除数据。<br>只有当没有事务再需要旧版本时，<strong>VACUUM</strong> 才会真正清理物理空间。</li>
</ol>
<h3 id="可见性判断"><a href="#可见性判断" class="headerlink" title="可见性判断"></a>可见性判断</h3><p><strong>一个事务在查询时，系统会根据当前事务的快照（snapshot）来判断哪些版本可见。<br>快照记录：当前事务 ID，当前已提交事务 ID 集合，当前未提交事务 ID 集合。</strong></p>
<blockquote>
<p>可见性判断是“快照”对“版本”的比较。<br>✅ “快照认为这个版本已经存在（被提交），并且还没被删除” → 可见<br>❌ “快照认为这个版本还没生成，或已经被删除” → 不可见</p>
</blockquote>
<p>所以“是否可见”是针对当前事务(的快照)视角而言的。</p>
<p>判断规则：</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>是否可见</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>tuple 的 <code>xmin</code> 未提交</td>
<td>❌ 不可见</td>
<td>事务还没提交当然不可见</td>
</tr>
<tr>
<td>tuple 的 <code>xmin</code> 已提交，且 <code>xmax</code> 为空</td>
<td>✅ 可见</td>
<td>xmax为null说明版本是最新的</td>
</tr>
<tr>
<td>tuple 的 <code>xmin</code> 已提交，但 <code>xmax</code> 已提交（并早于当前事务）</td>
<td>❌ 不可见</td>
<td>xmax已经提交说明该版本已经过时了</td>
</tr>
<tr>
<td>tuple 的 <code>xmax</code> 是未提交事务</td>
<td>✅（快照隔离下仍可见）</td>
<td>xmax还未提交相当于xmax保持初始值即null</td>
</tr>
</tbody></table>
<h3 id="MVCC-与事务隔离级别的关系"><a href="#MVCC-与事务隔离级别的关系" class="headerlink" title="MVCC 与事务隔离级别的关系"></a>MVCC 与事务隔离级别的关系</h3><table>
<thead>
<tr>
<th>隔离级别</th>
<th>MVCC 的表现</th>
</tr>
</thead>
<tbody><tr>
<td><strong>READ COMMITTED</strong></td>
<td>每次查询都获得<strong>新的快照</strong>（看到已提交的新数据）</td>
</tr>
<tr>
<td><strong>REPEATABLE READ</strong></td>
<td>整个事务期间使用<strong>固定的快照</strong>（避免不可重复读）</td>
</tr>
<tr>
<td><strong>SERIALIZABLE</strong></td>
<td>在 MVCC 基础上加额外检测，确保结果等价于串行执行</td>
</tr>
</tbody></table>
<hr>
<h1 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h1><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>window_function<span class="operator">&gt;</span>(args) <span class="keyword">OVER</span> (</span><br><span class="line">    [<span class="keyword">PARTITION</span> <span class="keyword">BY</span> expr [, ...]]</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> expr [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>] [, ...]]</span><br><span class="line">    [frame_clause]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>PARTITION BY</code>：定义分区，即窗口划分（类似 GROUP BY，但不折叠行）。  </li>
<li><code>ORDER BY</code>：定义窗口内行的逻辑顺序（影响排名、累积等）。  </li>
<li><code>frame_clause</code>：定义窗口的行范围（例如前 2 行到当前行），常用的类型：<code>ROWS</code>, <code>RANGE</code>, <code>GROUPS</code>。</li>
</ul>
<h3 id="常见窗口函数与用途"><a href="#常见窗口函数与用途" class="headerlink" title="常见窗口函数与用途"></a>常见窗口函数与用途</h3><ul>
<li><strong>排名类</strong>：<code>ROW_NUMBER()</code>, <code>RANK()</code>, <code>DENSE_RANK()</code>。  </li>
<li><strong>偏移类</strong>：<code>LAG(expr, offset, default)</code>, <code>LEAD(expr, offset, default)</code>。  </li>
<li><strong>窗口聚合</strong>：<code>SUM()</code>, <code>AVG()</code>, <code>COUNT()</code> 等可作为窗口函数使用。  </li>
<li><strong>FIRST_VALUE &#x2F; LAST_VALUE</strong>：获取窗口内首&#x2F;末值。</li>
</ul>
<h3 id="FRAME-子句详解（关键）"><a href="#FRAME-子句详解（关键）" class="headerlink" title="FRAME 子句详解（关键）"></a>FRAME 子句详解（关键）</h3><ul>
<li>语法（示例）：<code>ROWS BETWEEN 2 PRECEDING AND CURRENT ROW</code> 或 <code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>。  </li>
<li><strong>ROWS</strong>：基于物理行数，例如“前 2 行到当前行”。  </li>
<li><strong>RANGE</strong>：基于值范围（对 ORDER BY 列的值相等或范围判断），在含有相同 ORDER BY 值时区别明显。  </li>
<li><strong>默认行为</strong>：如果指定了 <code>ORDER BY</code> 但未指定 <code>frame_clause</code>，PostgreSQL 默认的窗口帧通常是 <code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code></li>
</ul>
<hr>
<h2 id="窗口函数-与-GROUP-BY-的对比"><a href="#窗口函数-与-GROUP-BY-的对比" class="headerlink" title="窗口函数 与 GROUP BY 的对比"></a>窗口函数 与 GROUP BY 的对比</h2><h3 id="核心差别"><a href="#核心差别" class="headerlink" title="核心差别"></a>核心差别</h3><ul>
<li><strong>行为</strong>：<code>GROUP BY</code> 会把多行“压缩”成每个分组一行；<code>OVER</code> 会<strong>保留所有原始行</strong>，并为每行附加窗口计算结果。  </li>
<li><strong>用途</strong>：<code>GROUP BY</code> 用于生成分组级统计（报告&#x2F;汇总）；<code>OVER</code> 用于在明细行上做分析（排名、累加、分区统计等）。</li>
<li><strong>在 SELECT 中的限制</strong>：使用 <code>GROUP BY</code> 时，SELECT 中出现的非聚合列必须出现在 GROUP BY 子句中；而 <code>OVER</code> 可以在SELECT中与普通列并存。</li>
</ul>
<h3 id="执行顺序相关"><a href="#执行顺序相关" class="headerlink" title="执行顺序相关"></a>执行顺序相关</h3><ul>
<li>查询执行顺序（与 GROUP BY, HAVING, OVER 相关）通常是：<br><code>FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT (包括窗口函数计算) -&gt; ORDER BY -&gt; LIMIT</code>。  </li>
<li>换句话说，窗口函数（OVER）在分组&#x2F;聚合之后计算，因此可以访问分组聚合的结果，但不能出现在 WHERE 或 GROUP BY 或 HAVING 子句中。</li>
</ul>
<h3 id="示例数据（employees）"><a href="#示例数据（employees）" class="headerlink" title="示例数据（employees）"></a>示例数据（employees）</h3><table>
<thead>
<tr>
<th>name</th>
<th>department</th>
<th>salary</th>
</tr>
</thead>
<tbody><tr>
<td>Alice</td>
<td>HR</td>
<td>5000</td>
</tr>
<tr>
<td>Bob</td>
<td>HR</td>
<td>6000</td>
</tr>
<tr>
<td>Carol</td>
<td>IT</td>
<td>7000</td>
</tr>
<tr>
<td>David</td>
<td>IT</td>
<td>8000</td>
</tr>
<tr>
<td>Eve</td>
<td>Sales</td>
<td>4000</td>
</tr>
<tr>
<td>Frank</td>
<td>Sales</td>
<td>4500</td>
</tr>
</tbody></table>
<p><strong>示例 A — 使用 GROUP BY（部门级平均工资）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> dept_avg, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> cnt</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong></p>
<table>
<thead>
<tr>
<th>department</th>
<th>dept_avg</th>
<th>cnt</th>
</tr>
</thead>
<tbody><tr>
<td>HR</td>
<td>5500</td>
<td>2</td>
</tr>
<tr>
<td>IT</td>
<td>7500</td>
<td>2</td>
</tr>
<tr>
<td>Sales</td>
<td>4250</td>
<td>2</td>
</tr>
</tbody></table>
<p><strong>说明</strong>：每个部门只有一行（分组级别）。</p>
<p><strong>示例 B — 使用窗口函数（在每一行展示部门平均工资）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, department, salary,</span><br><span class="line">       <span class="built_in">AVG</span>(salary) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department) <span class="keyword">AS</span> dept_avg,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department) <span class="keyword">AS</span> dept_count</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department, salary;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong></p>
<table>
<thead>
<tr>
<th>name</th>
<th>department</th>
<th>salary</th>
<th>dept_avg</th>
<th>dept_count</th>
</tr>
</thead>
<tbody><tr>
<td>Alice</td>
<td>HR</td>
<td>5000</td>
<td>5500</td>
<td>2</td>
</tr>
<tr>
<td>Bob</td>
<td>HR</td>
<td>6000</td>
<td>5500</td>
<td>2</td>
</tr>
<tr>
<td>Carol</td>
<td>IT</td>
<td>7000</td>
<td>7500</td>
<td>2</td>
</tr>
<tr>
<td>David</td>
<td>IT</td>
<td>8000</td>
<td>7500</td>
<td>2</td>
</tr>
<tr>
<td>Eve</td>
<td>Sales</td>
<td>4000</td>
<td>4250</td>
<td>2</td>
</tr>
<tr>
<td>Frank</td>
<td>Sales</td>
<td>4500</td>
<td>4250</td>
<td>2</td>
</tr>
</tbody></table>
<p><strong>说明</strong>：明细行保留，同时每行多出分组统计列。</p>
<h3 id="什么时候用哪一个？"><a href="#什么时候用哪一个？" class="headerlink" title="什么时候用哪一个？"></a>什么时候用哪一个？</h3><ul>
<li>只需要分组汇总（行折叠） → 使用 <code>GROUP BY</code>（更语义清晰，通常更高效）。  </li>
<li>需要按明细行显示并且同时显示分组统计 → 使用 <code>OVER</code>（保留明细并做分析）。</li>
</ul>
<h3 id="性能提示"><a href="#性能提示" class="headerlink" title="性能提示"></a>性能提示</h3><ul>
<li><code>GROUP BY</code> 常用 Hash Aggregate 或 Sort+Aggregate，可利用合适索引或并行聚合提升性能。  </li>
<li>窗口函数通常需要对 <code>PARTITION BY</code>&#x2F;<code>ORDER BY</code> 列进行排序；对于大表，排序开销与内存（work_mem）有关。  </li>
<li>如果想在窗口内做累积（running sum），可以考虑先按 partition&#x2F;order 排序再使用 <code>ROWS</code> 窗口框架来提高可预测性。</li>
</ul>
<hr>
<h1 id="继承-INHERITS"><a href="#继承-INHERITS" class="headerlink" title="继承(INHERITS)"></a>继承(INHERITS)</h1><p>在 PostgreSQL 中，继承（table inheritance） 是一个比较独特的特性，它允许一个表继承另一个表的列定义和约束，有点类似于面向对象编程中的“类继承”。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>父表（parent table）：定义了基本的字段和约束。</p>
</li>
<li><p>子表（child table）：继承父表的列和约束，同时可以定义自己的新列和约束。</p>
</li>
</ul>
<p>这样，子表天然拥有父表的所有列，并且你可以在查询父表时自动查询到子表的数据（除非显式限制）。</p>
<h3 id="继承示例"><a href="#继承示例" class="headerlink" title="继承示例"></a>继承示例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 父表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name TEXT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    salary <span class="type">NUMERIC</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子表，继承父表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> managers (</span><br><span class="line">    department TEXT</span><br><span class="line">) INHERITS (employees);</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>managers 继承了 employees 的 id, name, salary 三个字段。</li>
<li>managers 自己还定义了 department 列。</li>
</ul>
<h3 id="继承的查询特性"><a href="#继承的查询特性" class="headerlink" title="继承的查询特性"></a>继承的查询特性</h3><p>查询特性</p>
<p>当你查询父表时，默认会包括其所有子表的数据：<br><code>SELECT * FROM employees;</code><br>结果会包含 employees 表和 managers 表的数据。</p>
<p>如果只想查父表的数据，可以使用 ONLY：<br><code>SELECT * FROM ONLY employees;</code><br>这样只会返回父表自身的数据。</p>
<h3 id="继承的局限性"><a href="#继承的局限性" class="headerlink" title="继承的局限性"></a>继承的局限性</h3><p>虽然继承听起来很强大，但在实际生产中 PostgreSQL 的继承特性有不少限制：</p>
<ol>
<li><p>约束不会自动传播</p>
</li>
<li><p>父表上的约束（比如 PRIMARY KEY、UNIQUE）不会自动应用到子表。<br>如果你希望唯一性跨父表和子表生效，需要手动建约束或触发器。</p>
</li>
<li><p>索引不继承</p>
</li>
<li><p>父表的索引不会应用到子表，需要单独创建。</p>
</li>
<li><p>外键不支持继承</p>
</li>
<li><p>不能直接把外键建在父表上并自动作用于子表。</p>
</li>
<li><p>SQL 标准兼容性差<br>SQL 标准中没有这种表继承机制，因此它是 PostgreSQL 的“特有扩展”。</p>
</li>
</ol>
<h1 id="索引-INDEX"><a href="#索引-INDEX" class="headerlink" title="索引(INDEX)"></a>索引(INDEX)</h1><p>索引（Index）是数据库中一种<strong>用于加快数据检索速度</strong>的数据结构。<br>有索引，数据库可<strong>直接跳转到匹配的页</strong>（page），而不用全表扫描挨个对比。极大提升查询效率。当然索引也有代价，建立和维护索引需要额外空间和写入开销。</p>
<p>一旦一个索引被创建，就不再需要进一步的干预：系统会在表更新时自动更新索引，而且会在它觉得使用索引比顺序扫描表效率更高时使用索引。但我们可能需要定期地运行<code>ANALYZE</code>命令来更新统计信息以便查询规划器能做出正确的决定。</p>
<h2 id="创建和删除"><a href="#创建和删除" class="headerlink" title="创建和删除"></a>创建和删除</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个单列索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX test1_id_index <span class="keyword">ON</span> test1 (id);</span><br><span class="line"><span class="comment">-- 创建一个组合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX test1_id_name_index <span class="keyword">ON</span> test1 (id,name);</span><br><span class="line"><span class="comment">-- 创建唯一索引(不允许任何重复的值插入到表中)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX test1_unique_id_index <span class="keyword">ON</span> test1 (id);</span><br><span class="line"><span class="comment">--创建一个局部索引(在表的子集上构建的索引)</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX test1_id_index </span><br><span class="line"><span class="keyword">ON</span> test1 (id)</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"><span class="comment">-- 删除该索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX test1_id_index</span><br></pre></td></tr></table></figure>

<h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><p><code>PostgreSQL</code>支持的索引类型包括：B-tree（默认）、HASH、GiST、GIN、BRIN等。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DBA/" rel="tag">DBA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MVCC/" rel="tag">MVCC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Postgre/" rel="tag">Postgre</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2025/10/01/psql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            psql常用命令
          
        </div>
      </a>
    
    
      <a href="/2025/10/01/SQL%E5%9F%BA%E7%A1%80/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">SQL基础</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2025
        <i class="ri-heart-fill heart_icon"></i> Hexo
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/smile-circle-side.svg" alt="24stage"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2023/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>