<!DOCTYPE html>


<html lang="zh-hans">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="24stage Blog" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>SQL高级特性 |  24stage</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/smile.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-SQL高级特性"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  SQL高级特性
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/10/01/SQL%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" class="article-date">
  <time datetime="2025-10-01T14:17:05.000Z" itemprop="datePublished">2025-10-01</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">4.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">16 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="视图-VIEW"><a href="#视图-VIEW" class="headerlink" title="视图(VIEW)"></a>视图(VIEW)</h1><p>视图（View）是基于 SQL 查询结果创建的虚拟表，本身不存储数据，而是保存一条 SQL 查询定义。  </p>
<ul>
<li>当访问视图时，数据库会执行定义视图的查询，并返回结果。  </li>
<li><strong>用途</strong>：  <ul>
<li>简化复杂 SQL 查询，提高可读性。  </li>
<li>对用户隐藏表结构，起到安全隔离作用。  </li>
<li>可用于权限控制，限制用户访问数据的范围。</li>
</ul>
</li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> high_salary <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> name, salary</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">10000</span>;</span><br></pre></td></tr></table></figure>
使用时：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> high_salary;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h1><p>事务是所有数据库系统的基础概念。事务最重要的一点是它将多个步骤捆绑成了一个单一的、要么全完成要么全不完成的操作。步骤之间的中间状态对于其他并发事务是不可见的，并且如果有某些错误发生导致事务不能完成，则其中任何一个步骤都不会对数据库造成影响。</p>
<h3 id="事务与-ACID"><a href="#事务与-ACID" class="headerlink" title="事务与 ACID"></a>事务与 ACID</h3><ul>
<li><strong>原子性（Atomicity）</strong>：事务内的所有操作要么全部成功（COMMIT），要么全部撤销（ROLLBACK）。  </li>
<li><strong>一致性（Consistency）</strong>：事务结束时，数据库从一个一致状态转到另一个一致状态（例如外键、约束未被破坏）。  </li>
<li><strong>隔离性（Isolation）</strong>：并发事务之间互不干扰；一个事务在提交前的中间修改对其他事务不可见，避免脏读、不可重复读、幻读等问题。</li>
<li><strong>持久性（Durability）</strong>：一旦事务提交，修改被持久保存（WAL 日志保证）。</li>
</ul>
<h3 id="基本事务控制语句（PostgreSQL）"><a href="#基本事务控制语句（PostgreSQL）" class="headerlink" title="基本事务控制语句（PostgreSQL）"></a>基本事务控制语句（PostgreSQL）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 显式事务块</span></span><br><span class="line"><span class="keyword">BEGIN</span>;           <span class="comment">-- 或 START TRANSACTION;</span></span><br><span class="line">  <span class="comment">-- 若干 DML/DDL/查询</span></span><br><span class="line"><span class="keyword">COMMIT</span>;          <span class="comment">-- 提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果要撤销</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 保存点</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> sp1;</span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> sp1;</span><br><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> sp1;</span><br></pre></td></tr></table></figure>

<h3 id="自动提交（Autocommit）"><a href="#自动提交（Autocommit）" class="headerlink" title="自动提交（Autocommit）"></a>自动提交（Autocommit）</h3><ul>
<li>PostgreSQL 默认 <strong>自动提交</strong> 模式：如果不显式使用 BEGIN，数据库会把每条独立语句当作一个隐式事务执行（成功则立即提交）。</li>
</ul>
<h3 id="隔离级别与并发现象"><a href="#隔离级别与并发现象" class="headerlink" title="隔离级别与并发现象"></a>隔离级别与并发现象</h3><p>PostgreSQL 支持标准的隔离级别（但实际 READ UNCOMMITTED 被视作 READ COMMITTED）：</p>
<ol>
<li><p><strong>READ COMMITTED（默认）</strong>  </p>
<ul>
<li>每个语句只能看到其他事务已提交的更改。  </li>
<li>可能发生“不可重复读”（同一事务内相同查询得到不同结果）。</li>
</ul>
</li>
<li><p><strong>REPEATABLE READ</strong>  </p>
<ul>
<li>事务范围内的相同查询返回一致结果（解决不可重复读）；仍可能出现幻读</li>
</ul>
</li>
<li><p><strong>SERIALIZABLE</strong>  </p>
<ul>
<li>最严格的隔离级别，保证结果等价于某种串行执行（可能导致事务冲突并回滚）。</li>
</ul>
</li>
</ol>
<blockquote>
<p>注：PostgreSQL 的具体并发现象与隔离级别实现细节相对复杂，建议在生产场景选择合适隔离级别并通过测试验证。</p>
</blockquote>
<hr>
<h1 id="锁-的机制和管理"><a href="#锁-的机制和管理" class="headerlink" title="锁 的机制和管理"></a>锁 的机制和管理</h1><p>在 <code>PostgreSQL</code> 中，锁（Lock）是用来<strong>控制多个事务对同一资源并发访问的同步机制</strong>。当多个事务同时访问数据库的同一份数据时，锁用于防止数据不一致、保持隔离性。锁是实现隔离性的核心机制，用于协调多个事务对共享资源（数据页、行、表等）的访问。</p>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><table>
<thead>
<tr>
<th>锁类型</th>
<th>作用对象</th>
<th>使用场景</th>
<th>特征</th>
</tr>
</thead>
<tbody><tr>
<td><strong>表级锁（Table-level Lock）</strong></td>
<td>整个表</td>
<td>DDL &#x2F; DML 语句</td>
<td>粒度大，持有时间短</td>
</tr>
<tr>
<td><strong>行级锁（Row-level Lock）</strong></td>
<td>单行记录</td>
<td><code>SELECT ... FOR UPDATE</code>、<code>UPDATE</code>、<code>DELETE</code></td>
<td>精细化控制，MVCC 兼容</td>
</tr>
<tr>
<td><strong>页级锁（Page-level Lock）</strong></td>
<td>数据页（8KB）</td>
<td>VACUUM、索引维护</td>
<td>系统内部使用</td>
</tr>
<tr>
<td><strong>事务锁（Transaction-level Lock）</strong></td>
<td>事务ID（XID）</td>
<td>防止提交&#x2F;回滚冲突</td>
<td>内部依赖</td>
</tr>
<tr>
<td><strong>轻量级锁（Lightweight Lock, LWLock）</strong></td>
<td>内部共享结构</td>
<td>缓冲区、WAL 管理</td>
<td>非用户可见</td>
</tr>
<tr>
<td><strong>自旋锁（SpinLock）</strong></td>
<td>CPU 级同步</td>
<td>临界区保护</td>
<td>极短期锁，用于内核代码</td>
</tr>
</tbody></table>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁及兼容性：</p>
<table>
<thead>
<tr>
<th>锁模式</th>
<th>常见触发操作</th>
<th>与其他锁兼容性（✅兼容 ❌冲突）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>AccessShareLock</strong></td>
<td><code>SELECT</code></td>
<td>✅ 大多数锁（除Exclusive）</td>
</tr>
<tr>
<td><strong>RowShareLock</strong></td>
<td><code>SELECT ... FOR UPDATE/SHARE</code></td>
<td>❌ Exclusive</td>
</tr>
<tr>
<td><strong>RowExclusiveLock</strong></td>
<td><code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code></td>
<td>❌ 共享类锁</td>
</tr>
<tr>
<td><strong>ShareUpdateExclusiveLock</strong></td>
<td><code>VACUUM</code>、<code>ANALYZE</code>、<code>CREATE INDEX CONCURRENTLY</code></td>
<td>⚠️ 限制中等</td>
</tr>
<tr>
<td><strong>ShareLock</strong></td>
<td><code>CREATE INDEX</code></td>
<td>❌ 与更新锁冲突</td>
</tr>
<tr>
<td><strong>ShareRowExclusiveLock</strong></td>
<td><code>CREATE TRIGGER</code></td>
<td>❌ 几乎所有写锁</td>
</tr>
<tr>
<td><strong>ExclusiveLock</strong></td>
<td><code>ALTER TABLE</code></td>
<td>❌ 除 AccessShareLock 外均冲突</td>
</tr>
<tr>
<td><strong>AccessExclusiveLock</strong></td>
<td><code>DROP TABLE</code>、<code>TRUNCATE</code>、<code>REINDEX</code></td>
<td>❌ 与所有锁冲突</td>
</tr>
</tbody></table>
<h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><table>
<thead>
<tr>
<th>锁模式</th>
<th>语句来源</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FOR UPDATE</strong></td>
<td><code>SELECT ... FOR UPDATE</code></td>
<td>阻止他人修改&#x2F;删除该行</td>
</tr>
<tr>
<td><strong>FOR NO KEY UPDATE</strong></td>
<td><code>UPDATE</code>（未更改主键时）</td>
<td>允许其他事务 FOR KEY SHARE</td>
</tr>
<tr>
<td><strong>FOR SHARE</strong></td>
<td><code>SELECT ... FOR SHARE</code></td>
<td>允许并发读，阻止修改</td>
</tr>
<tr>
<td><strong>FOR KEY SHARE</strong></td>
<td><code>SELECT ... FOR KEY SHARE</code></td>
<td>最弱行锁，允许更新非主键字段</td>
</tr>
</tbody></table>
<h2 id="轻量级锁与自旋锁"><a href="#轻量级锁与自旋锁" class="headerlink" title="轻量级锁与自旋锁"></a>轻量级锁与自旋锁</h2><table>
<thead>
<tr>
<th>锁类型</th>
<th>用途</th>
<th>粒度</th>
<th>特征</th>
</tr>
</thead>
<tbody><tr>
<td><strong>轻量级锁LWLock</strong></td>
<td>保护共享结构，如缓冲区链表、WAL缓冲区</td>
<td>中等</td>
<td>支持共享&#x2F;独占模式</td>
</tr>
<tr>
<td><strong>自旋锁SpinLock</strong></td>
<td>极短代码段的同步</td>
<td>微观</td>
<td>忙等，不可睡眠</td>
</tr>
</tbody></table>
<h2 id="锁的实现机制以及流程"><a href="#锁的实现机制以及流程" class="headerlink" title="锁的实现机制以及流程"></a>锁的实现机制以及流程</h2><p>PostgreSQL 使用一套统一的 Lock Manager（锁管理器）实现所有表级、行级及事务锁。<br>所有锁信息存放于 <strong>共享内存</strong>（Shared Memory）；<br><strong>锁的主要结构：</strong></p>
<ul>
<li>LOCKTAG：锁对象标识（如 relation、tuple、transaction）；</li>
<li>LOCK：实际锁结构；</li>
<li>PROCLOCK：事务与锁对象的对应关系。</li>
</ul>
<p><strong>锁请求流程：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事务请求锁 →</span><br><span class="line">Lock Manager 检查兼容性 →</span><br><span class="line">若冲突则进入等待队列 →</span><br><span class="line">被唤醒后获得锁 →</span><br><span class="line">操作完成后释放锁</span><br></pre></td></tr></table></figure>
<p><strong>可以通过<code>pg_locks</code>查看当前锁的情况：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pid, locktype, mode, granted, relation::regclass <span class="keyword">AS</span> <span class="keyword">table</span>, virtualtransaction</span><br><span class="line"><span class="keyword">FROM</span> pg_locks</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> granted <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC(多版本并发控制)"></a>MVCC(多版本并发控制)</h1><p>简单说，它让多个事务可以同时访问同一张表的数据，<br>而又互不干扰、互不锁表。</p>
<p>传统的并发控制方式是加锁（Locking）：<br>当一个事务正在修改某行数据时，其他事务必须等待,并发性能差。</p>
<p><strong>而 MVCC 不加锁读取数据：</strong></p>
<ul>
<li>读操作读取“历史快照（snapshot）”，不阻塞写；</li>
<li>写操作创建“新版本（new version）”，不阻塞读。</li>
</ul>
<blockquote>
<p>✅ 核心思想：数据库中的每一行数据都有多个版本（versions），不同事务可以看到不同版本的数据。</p>
</blockquote>
<h2 id="核心机制："><a href="#核心机制：" class="headerlink" title="核心机制："></a>核心机制：</h2><p>在 PostgreSQL 中，每一行数据（tuple）都包含以下两个隐藏字段：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>xmin</code></td>
<td>插入该行的事务 ID</td>
</tr>
<tr>
<td><code>xmax</code></td>
<td>删除（或更新）该行的事务 ID</td>
</tr>
</tbody></table>
<p>当一个事务读取数据时，它根据自己的“<strong>快照（snapshot）</strong>”决定：</p>
<ul>
<li>哪些版本是可见的；</li>
<li>哪些版本是对自己不可见的（未提交或已删除）。</li>
</ul>
<p><strong>PostgreSQL 的 UPDATE 实际上是 “删除旧行 + 插入新行”；</strong></p>
<p>MVCC 的实现方式总结:</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>动作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>SELECT</strong></td>
<td>读取可见版本</td>
<td>不加锁，只看快照</td>
</tr>
<tr>
<td><strong>UPDATE</strong></td>
<td>创建一个新版本（新行）</td>
<td>原版本打上 xmax，表示“过期”</td>
</tr>
<tr>
<td><strong>DELETE</strong></td>
<td>设置 xmax</td>
<td>逻辑删除，不立即物理删除</td>
</tr>
<tr>
<td><strong>VACUUM</strong></td>
<td>清理旧版本</td>
<td>回收空间，防止膨胀</td>
</tr>
</tbody></table>
<h2 id="示例：多版本快照"><a href="#示例：多版本快照" class="headerlink" title="示例：多版本快照"></a>示例：多版本快照</h2><ol>
<li><p>事务 T1 执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Alice&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>系统会：<br>为这行记录生成一个新的版本,设置 <code>xmin = T1</code>, <code>xmax = null（未被删除）</code>；</p>
</li>
<li><p>事务T2 执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> users</span><br><span class="line"><span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;newAlice&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>系统会：更新不是原地修改，而是复制出一行新版本（新 tuple）；<br>旧版本的 xmax 被设为当前事务 ID；<br>新版本的 xmin 被设为当前事务 ID。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>版本</th>
<th>内容</th>
<th>xmin</th>
<th>xmax</th>
</tr>
</thead>
<tbody><tr>
<td>v1</td>
<td>Alice</td>
<td>10 (T1)</td>
<td>20(T2)</td>
</tr>
<tr>
<td>v2</td>
<td>newAlice</td>
<td>20(T2)</td>
<td>null</td>
</tr>
</tbody></table>
<ol start="3">
<li>DELETE<br>删除操作只是在记录上标记 <code>xmax = 当前事务ID</code>，不立即移除数据。<br>只有当没有事务再需要旧版本时，<strong>VACUUM</strong> 才会真正清理物理空间。</li>
</ol>
<h2 id="可见性判断"><a href="#可见性判断" class="headerlink" title="可见性判断"></a>可见性判断</h2><p><strong>一个事务在查询时，系统会根据当前事务的快照（snapshot）来判断哪些版本可见。<br>快照记录：当前事务 ID，当前已提交事务 ID 集合，当前未提交事务 ID 集合。</strong></p>
<blockquote>
<p>可见性判断是“快照”对“版本”的比较。<br>✅ “快照认为这个版本已经存在（被提交），并且还没被删除” → 可见<br>❌ “快照认为这个版本还没生成，或已经被删除” → 不可见</p>
</blockquote>
<p>所以“是否可见”是针对当前事务(的快照)视角而言的。</p>
<p>判断规则：</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>是否可见</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>tuple 的 <code>xmin</code> 未提交</td>
<td>❌ 不可见</td>
<td>事务还没提交当然不可见</td>
</tr>
<tr>
<td>tuple 的 <code>xmin</code> 已提交，且 <code>xmax</code> 为空</td>
<td>✅ 可见</td>
<td>xmax为null说明版本是最新的</td>
</tr>
<tr>
<td>tuple 的 <code>xmin</code> 已提交，但 <code>xmax</code> 已提交（并早于当前事务）</td>
<td>❌ 不可见</td>
<td>xmax已经提交说明该版本已经过时了</td>
</tr>
<tr>
<td>tuple 的 <code>xmax</code> 是未提交事务</td>
<td>✅（快照隔离下仍可见）</td>
<td>xmax还未提交相当于xmax保持初始值即null</td>
</tr>
</tbody></table>
<h2 id="MVCC-与事务隔离级别的关系"><a href="#MVCC-与事务隔离级别的关系" class="headerlink" title="MVCC 与事务隔离级别的关系"></a>MVCC 与事务隔离级别的关系</h2><table>
<thead>
<tr>
<th>隔离级别</th>
<th>MVCC 的表现</th>
</tr>
</thead>
<tbody><tr>
<td><strong>READ COMMITTED</strong></td>
<td>每次查询都获得<strong>新的快照</strong>（看到已提交的新数据）</td>
</tr>
<tr>
<td><strong>REPEATABLE READ</strong></td>
<td>整个事务期间使用<strong>固定的快照</strong>（避免不可重复读）</td>
</tr>
<tr>
<td><strong>SERIALIZABLE</strong></td>
<td>在 MVCC 基础上加额外检测，确保结果等价于串行执行</td>
</tr>
</tbody></table>
<h2 id="死元组（dead-tuple）"><a href="#死元组（dead-tuple）" class="headerlink" title="死元组（dead tuple）"></a>死元组（dead tuple）</h2><p>每当你<strong>修改或删除</strong>一行数据时，旧版本不会被立即覆盖或删除，而是被保留，并打上“过期”标记。这就产生了死元组，此外还有一中情况：即<strong>事务回滚</strong>操作也会产生死元组(新版本已经插入，但事务回滚后它对所有事务都不可见。即使更新失败也会产生)</p>
<p>这些不可见版本也是 dead tuple。</p>
<blockquote>
<p><code>PostgreSQL</code> 采用 非阻塞式 <code>MVCC</code>，允许读写并发。当一行数据(元组)被更新或删除时，如果立即将该元组删除，其他仍在运行的事务可能仍需访问旧版本。因此，旧版本要等到没有任何活跃事务需要它后，才能被回收。</p>
</blockquote>
<hr>
<h1 id="继承-INHERITS"><a href="#继承-INHERITS" class="headerlink" title="继承(INHERITS)"></a>继承(INHERITS)</h1><p>在 PostgreSQL 中，继承（table inheritance） 是一个比较独特的特性，它允许一个表继承另一个表的列定义和约束，有点类似于面向对象编程中的“类继承”。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>父表（parent table）：定义了基本的字段和约束。</p>
</li>
<li><p>子表（child table）：继承父表的列和约束，同时可以定义自己的新列和约束。</p>
</li>
</ul>
<p>这样，子表天然拥有父表的所有列，并且你可以在查询父表时自动查询到子表的数据（除非显式限制）。</p>
<h3 id="继承示例"><a href="#继承示例" class="headerlink" title="继承示例"></a>继承示例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 父表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name TEXT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    salary <span class="type">NUMERIC</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子表，继承父表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> managers (</span><br><span class="line">    department TEXT</span><br><span class="line">) INHERITS (employees);</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>managers 继承了 employees 的 id, name, salary 三个字段。</li>
<li>managers 自己还定义了 department 列。</li>
</ul>
<h3 id="继承的查询特性"><a href="#继承的查询特性" class="headerlink" title="继承的查询特性"></a>继承的查询特性</h3><p>查询特性</p>
<p>当你查询父表时，默认会包括其所有子表的数据：<br><code>SELECT * FROM employees;</code><br>结果会包含 employees 表和 managers 表的数据。</p>
<p>如果只想查父表的数据，可以使用 ONLY：<br><code>SELECT * FROM ONLY employees;</code><br>这样只会返回父表自身的数据。</p>
<h3 id="继承的局限性"><a href="#继承的局限性" class="headerlink" title="继承的局限性"></a>继承的局限性</h3><p>虽然继承听起来很强大，但在实际生产中 PostgreSQL 的继承特性有不少限制：</p>
<ol>
<li><p>约束不会自动传播</p>
</li>
<li><p>父表上的约束（比如 PRIMARY KEY、UNIQUE）不会自动应用到子表。<br>如果你希望唯一性跨父表和子表生效，需要手动建约束或触发器。</p>
</li>
<li><p>索引不继承</p>
</li>
<li><p>父表的索引不会应用到子表，需要单独创建。</p>
</li>
<li><p>外键不支持继承</p>
</li>
<li><p>不能直接把外键建在父表上并自动作用于子表。</p>
</li>
<li><p>SQL 标准兼容性差<br>SQL 标准中没有这种表继承机制，因此它是 PostgreSQL 的“特有扩展”。</p>
</li>
</ol>
<hr>
<h1 id="索引-INDEX"><a href="#索引-INDEX" class="headerlink" title="索引(INDEX)"></a>索引(INDEX)</h1><p>索引（Index）是数据库中一种<strong>用于加快数据检索速度</strong>的数据结构。<br>有索引，数据库可<strong>直接跳转到匹配的页</strong>（page），而不用全表扫描挨个对比。极大提升查询效率。当然索引也有代价，建立和维护索引需要额外空间和写入开销。</p>
<p>一旦一个索引被创建，就不再需要进一步的干预：系统会在表更新时自动更新索引，而且会在它觉得使用索引比顺序扫描表效率更高时使用索引。但我们可能需要定期地运行<code>ANALYZE</code>命令来更新统计信息以便查询规划器能做出正确的决定。</p>
<h2 id="创建和删除"><a href="#创建和删除" class="headerlink" title="创建和删除"></a>创建和删除</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个单列索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX test1_id_index <span class="keyword">ON</span> test1 (id);</span><br><span class="line"><span class="comment">-- 创建一个组合索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX test1_id_name_index <span class="keyword">ON</span> test1 (id,name);</span><br><span class="line"><span class="comment">-- 创建唯一索引(不允许任何重复的值插入到表中)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX test1_unique_id_index <span class="keyword">ON</span> test1 (id);</span><br><span class="line"><span class="comment">--创建一个局部索引(在表的子集上构建的索引)</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX test1_id_index </span><br><span class="line"><span class="keyword">ON</span> test1 (id)</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"><span class="comment">-- 删除该索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX test1_id_index</span><br></pre></td></tr></table></figure>

<h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><p><code>PostgreSQL</code>支持的索引类型包括：B+树（默认）、HASH、GiST、GIN、BRIN等。</p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>底层是一种多路平衡树（balanced tree），数据按键（key）有序排列，所有叶子节点深度一致（平衡性保证查找效率），并且每个节点存储一组有序键值与指针。</p>
<p>在 <code>PostgreSQL</code> 中，索引也是一种表结构，存储在 <strong>索引页（index page）</strong> 里。<br>每个索引页包含：</p>
<ul>
<li><strong>Page header</strong>：页头元信息（页号、空闲空间指针等）</li>
<li><strong>Item pointers</strong>：指向表中 元组 的指针（ctid）</li>
<li><strong>Key 数据</strong>：索引列的值（例如 name, id）</li>
<li><strong>链表指针</strong>：指向相邻叶子页（用于范围扫描）</li>
</ul>
<p>优点是：查找、插入、删除平均 O(log N)，支持范围与排序，适用于几乎所有普通查询<br>但也有一些缺点：插入过多会导致页分裂（page split），大量更新&#x2F;删除导致索引膨胀（bloat），不适合极端高写入负载场景（如日志）</p>
<p><strong>查找的流程：</strong><br>从根页（root page）开始，比较 <code>key</code> 值，确定要下探的分支页，然后递归直到叶子页，再在叶子页找到匹配 <code>key</code>，如果比较结果为 <code>=</code> 时，B+树索引会选择<strong>右子节点</strong>继续查找,最后返回该 <code>key</code> 指向的数据行（tuple）。</p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p><code>HASH</code>索引存储一个由索引列计算出的32位的hash code值。因此，<code>Hash</code>索引只能处理简单等值<code>=</code>比较。每当索引列涉及到等值操作符的比较时，查询规划器将会使用<code>Hash</code>索引。</p>
<h2 id="索引选择性（selectivity）和成本模型"><a href="#索引选择性（selectivity）和成本模型" class="headerlink" title="索引选择性（selectivity）和成本模型"></a>索引选择性（selectivity）和成本模型</h2><p>PostgreSQL 在执行 SQL 时，如何决定是否使用索引？<br>——答案关键在于<strong>索引选择性</strong>（selectivity）与<strong>成本估算</strong>（cost estimation）。</p>
<p><strong>索引选择性</strong>是指某个查询条件筛选出的行数占总行数的比例。</p>
<ul>
<li>选择性高（接近 1.0） → 命中很多行 → 索引没啥用；</li>
<li>选择性低（接近 0.0） → 命中很少行 → 索引非常有效。</li>
</ul>
<p>当然了，优化器不可能真的去“执行一遍”看看结果多少行。<br>它根据 系统统计信息（pg_statistic） 估算的，这些统计是在你执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE tablename;  <span class="comment">--ANALYZE 会扫描表中的部分数据行，</span></span><br><span class="line"><span class="comment">--生成统计信息并存入系统表 pg_statistic</span></span><br><span class="line">或</span><br><span class="line">VACUUM ANALYZE;</span><br></pre></td></tr></table></figure>
<p>时生成的。</p>
<p><code>PostgreSQL</code> 最终并不是只看 <code>selectivity</code>，而是综合计算“成本”。<br>每个执行计划都会有：</p>
<ul>
<li>startup_cost：启动开销（准备、扫描第一行）</li>
<li>total_cost：读完全部行的总成本（包括 I&#x2F;O、CPU 等）</li>
</ul>
<p>优化器根据统计信息与代价参数估算这些值。</p>
<h2 id="索引失效的常见原因"><a href="#索引失效的常见原因" class="headerlink" title="索引失效的常见原因"></a>索引失效的常见原因</h2><p><strong>1. 索引选择性低</strong><br>如果结果集占表的 20% 以上，优化器通常会放弃索引，改用顺序扫描（Seq Scan）。<br><strong>2. 数据类型不匹配</strong><br>PostgreSQL 的索引对数据类型非常严格。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_userid <span class="keyword">ON</span> users(userid <span class="type">INT</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 错误写法（字符串转整数）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> userid <span class="operator">=</span> <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>此时 <code>&#39;123&#39;</code> 是字符串常量，优化器不会隐式转换成 <code>int</code> 去匹配索引，因此索引失效。<br><strong>3. 在列上使用函数或表达式</strong><br>当你在 WHERE 子句中对列使用函数时，索引无法直接利用。<br>但是可以创建函数索引。<br><strong>4. 使用模糊查询<code>LIKE</code>时前缀以<code>%</code>开头</strong><br><code>B-tree </code>索引支持<code> LIKE &#39;abc%&#39;</code>，但不支持 <code>LIKE &#39;%abc&#39;</code>。<br><strong>5. 运算符或表达式不匹配索引类型</strong><br>例如，<code>B-tree</code> 索引支持 <code>&lt;, &lt;=, =, &gt;=, &gt;</code>，<br>但不支持 <code>!=</code> 或 <code>NOT IN</code>。<br><strong>6. 统计信息不准确&#x2F;过旧（ANALYZE 未更新）</strong><br>优化器依赖 <code>pg_statistic</code> 表的统计信息估算行数,如果表数据更新频繁但没执行 ANALYZE，优化器可能错误地认为索引代价高。<br><strong>7. 多列复合索引未按前缀顺序使用</strong><br>索引是按照最左匹配原则进行匹配的，<br>假设创建了：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_example <span class="keyword">ON</span> table_name(col1, col2, col3);</span><br></pre></td></tr></table></figure>
<p>在一个复合索引里，查询如果要有效利用这个索引，应当先匹配（或者在 WHERE 中明确过滤）第一个索引列 <code>col1</code>，然后才能匹配列 <code>col2</code>、再然后才能匹配列 <code>col3</code>。如果跳过了第一个列（或第一个和第二个），直接用 <code>col2</code> 或 <code>col3</code>，索引就不能被有效使用。<br><strong>8. 数据量太小或表太小</strong><br>当表只有几百行时，优化器计算发现：<br>“全表扫描只需一次磁盘读取”，而索引扫描需要“额外<strong>随机IO</strong> + 回表查元组”，所以索引也不会被使用。</p>
<h2 id="索引调优技巧"><a href="#索引调优技巧" class="headerlink" title="索引调优技巧"></a>索引调优技巧</h2><p><strong>1. 分析查询计划 (EXPLAIN &#x2F; EXPLAIN ANALYZE)</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN ANALYZE <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Tom&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>查看执行计划，如果是 Seq Scan → 没用索引，如果是 Index Scan &#x2F; Index Only Scan → 已使用索引<br><strong>2. 维护统计信息</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先清理再统计，防止统计包含过时数据</span></span><br><span class="line">VACUUM ANALYZE;</span><br></pre></td></tr></table></figure>
<p><strong>3. 使用函数索引或表达式索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_expr_salary <span class="keyword">ON</span> employees ((salary <span class="operator">*</span> <span class="number">12</span>));</span><br><span class="line"><span class="comment">-- 即可支持：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">*</span> <span class="number">12</span> <span class="operator">&gt;</span> <span class="number">120000</span>;</span><br></pre></td></tr></table></figure>
<p><strong>4. 使用部分索引</strong><br>如果查询经常限定某一条件：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"></span><br><span class="line">可以这样建索引：</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_pending_orders <span class="keyword">ON</span> orders (status) <span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;pending&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这样能极大减少索引大小与扫描成本。<br><strong>5. 避免数据类型不一致</strong></p>
<hr>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DBA/" rel="tag">DBA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MVCC/" rel="tag">MVCC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Postgre/" rel="tag">Postgre</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2025/10/01/psql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            LINUX管理常用工具
          
        </div>
      </a>
    
    
      <a href="/2025/10/01/SQL%E5%9F%BA%E7%A1%80/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">SQL基础</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2025
        <i class="ri-heart-fill heart_icon"></i> Hexo
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/smile-circle-side.svg" alt="24stage"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2023/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>