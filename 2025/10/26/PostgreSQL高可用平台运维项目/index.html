<!DOCTYPE html>


<html lang="zh-hans">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="24stage Blog" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>PostgreSQL高可用平台运维项目 |  24stage</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/smile.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-PostgreSQL高可用平台运维项目"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  PostgreSQL高可用平台运维项目
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/10/26/PostgreSQL%E9%AB%98%E5%8F%AF%E7%94%A8%E5%B9%B3%E5%8F%B0%E8%BF%90%E7%BB%B4%E9%A1%B9%E7%9B%AE/" class="article-date">
  <time datetime="2025-10-26T02:20:31.000Z" itemprop="datePublished">2025-10-26</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">8.9k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">38 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="大致流程-删除"><a href="#大致流程-删除" class="headerlink" title="大致流程(删除)"></a>大致流程(删除)</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">项目：PostgreSQL 运维 &amp; 高可用平台  </span><br><span class="line">├── 模块 A：备份与恢复系统  </span><br><span class="line">│     ├── 全量／增量备份脚本  </span><br><span class="line">│     ├── 恢复演练流程文档  </span><br><span class="line">│     └── 容灾脚本或模拟故障切换  </span><br><span class="line">├── 模块 B：主从复制＋故障切换架构  </span><br><span class="line">│     ├── 主库、从库部署（如两个节点）  </span><br><span class="line">│     ├── 使用 Patroni／etcd／HAProxy（或简化版本）实现自动切换  </span><br><span class="line">│     ├── 测试主库宕机＋切换流程文档  </span><br><span class="line">│     └── 延迟监控、同步机制说明  </span><br><span class="line">├── 模块 C：监控＋性能优化＋脚本自动化  </span><br><span class="line">      ├── 收集慢查询（如 pg_stat_statements）、执行 EXPLAIN 分析  </span><br><span class="line">      ├── 编写巡检脚本（检测锁等待、表膨胀、索引冗余等）  </span><br><span class="line">      ├── 部署监控平台（如 Prometheus + Grafana）展示指标  </span><br><span class="line">      └── 自动告警（邮件／微信／钉钉）或报告生成脚本  </span><br><span class="line">└── 文档／演示  </span><br><span class="line">      ├── 项目简介／架构图  </span><br><span class="line">      ├── 安装部署说明  </span><br><span class="line">      └── 简历版项目总结</span><br></pre></td></tr></table></figure>

<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><p>分别在腾讯云服务器和阿里云服务器上使用源码安装<code>PostgreSQL</code>,安装流程见<a href="./Postgre%E5%9C%A8Linux%E4%B8%8A%E7%9A%84%E5%AE%89%E8%A3%85.md">在Linux上安装PostgresSQL</a>。</p>
<h2 id="在主库部署-dvdrental-示例数据库"><a href="#在主库部署-dvdrental-示例数据库" class="headerlink" title="在主库部署 dvdrental 示例数据库"></a>在主库部署 dvdrental 示例数据库</h2><p>我的linux虚拟机上的<code>PostgreSQL</code>已经安装过了，因此只需导入数据库就行了。</p>
<p><strong>1. 下载示例数据库文件</strong><br>官方提供 .tar 备份文件（dvdrental.tar）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/src</span><br><span class="line">wget https://www.postgresqltutorial.com/wp-content/uploads/2019/05/dvdrental.zip</span><br><span class="line">unzip dvdrental.zip</span><br></pre></td></tr></table></figure>
<p>得到文件：dvdrental.tar<br><strong>2. 创建数据库并恢复数据</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">createdb -U wqstage dvdrental</span><br><span class="line">pg_restore -U wqstage -d dvdrental --no-owner --role=wqstage /usr/local/src/dvdrental.tar</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--no-owner</code> 忽略备份文件中记录的所有权信息。</li>
<li><code>--role=wqstage</code> 表示以当前用户恢复对象。<blockquote>
<p>这里出了一点小问题：因为我之前在导入拓展的时候误执行了apt命令安装，导致多了一个apt版本的postgreSQL实例，因此会报错pg_restore: error: connection to server on socket “&#x2F;var&#x2F;run&#x2F;postgresql&#x2F;.s.PGSQL.5433” failed: FATAL: role “wqstage” does not exist 。解决办法是先关闭apt版本的实例，然后执行<code>sudo systemctl disable postgresql</code>禁止其自启动。</p>
</blockquote>
</li>
</ul>
<ol start="3">
<li>最后验证<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> film;</span><br></pre></td></tr></table></figure>
结果返回1000行，导入成功。</li>
</ol>
<hr>
<h1 id="主从同步-复制-手动"><a href="#主从同步-复制-手动" class="headerlink" title="主从同步(复制)手动"></a>主从同步(复制)手动</h1><h2 id="主库配置"><a href="#主库配置" class="headerlink" title="主库配置"></a>主库配置</h2><p><strong>1. 修改<code> postgresql.conf</code></strong> （打开远程连接、启用 WAL&#x2F;归档等）<br>文件位置示例：<code>/usr/local/pgsql/data/postgresql.conf</code><br><strong>首先备份配置文件：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /usr/local/pgsql/data/postgresql.conf /usr/local/pgsql/data/postgresql.conf.bak</span><br></pre></td></tr></table></figure>
<p><strong>执行<code>vim postgresql.conf</code> 修改以下参数:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许外部主机连接数据库</span></span><br><span class="line">listen_addresses = <span class="string">&#x27;*&#x27;</span>              <span class="comment"># 解释: 允许来自任意 IP 的客户端连接（生产中按需限制）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># WAL / 复制相关（必须）</span></span><br><span class="line">wal_level = replica                 <span class="comment"># 解释: 生成足够的 WAL 信息用于物理复制（必需）</span></span><br><span class="line">max_wal_senders = 10                <span class="comment"># 解释: 同时允许的 WAL 发送进程数量（从库数量 + 余量）</span></span><br><span class="line">wal_keep_size = 64                  <span class="comment"># 解释: 保留多少 WAL 用于避免过早删除（单位 MB）</span></span><br><span class="line">archive_mode = on                   <span class="comment"># 解释: 启用 WAL 归档（做 PITR/归档备份时需要）</span></span><br><span class="line">archive_command = <span class="string">&#x27;cp %p /usr/local/src/archive/%f&#x27;</span></span><br><span class="line">                                    <span class="comment"># 解释: 将 WAL 文件复制到归档目录（</span></span><br></pre></td></tr></table></figure>

<p>因为修改了<code>archive_command</code>，所以还要手动创建一个<code>/usr/local/src/archive</code>目录并修改权限，因为<code>PostgreSQL</code>不会自动创建。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /usr/local/src/archive</span><br><span class="line">sudo <span class="built_in">chown</span> wqstage:wqstage /usr/local/src/archive</span><br><span class="line">sudo <span class="built_in">chmod</span> 700 /usr/local/src/archive</span><br></pre></td></tr></table></figure>
<p><strong>2. 创建 <code>replication</code>专用账号</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 习惯上我们用 postgres 或 template1 来执行管理操作，因为这些数据库通用且易于管理。</span></span><br><span class="line"><span class="comment"># 主从复制专用用户(因为是源码安装的，所以指定端口为5432)</span></span><br><span class="line">sudo -u postgres psql -h localhost -p 5432 -c <span class="string">&quot;CREATE ROLE replicator WITH REPLICATION LOGIN PASSWORD &#x27;replica_pass&#x27;;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 编辑 pg_hba.conf</strong><br>允许指定<code>用户</code>从指定 <code>IP</code> 地址以复制 (replication) 权限连接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/pgsql/data/pg_hba.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许 standby 用 replicator 用户做 replication</span></span><br><span class="line">host replication replicator &lt;STANDBY_IP&gt;/32 md5</span><br></pre></td></tr></table></figure>
<p><strong>4. 重启 PostgreSQL 使配置生效</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pg_ctl restart</span><br></pre></td></tr></table></figure>
<h2 id="内网组建"><a href="#内网组建" class="headerlink" title="内网组建"></a>内网组建</h2><p>首先我的一台虚拟机和云服务器不在一个局域网，我选择使用<code>Tailscale</code>进行内网穿透。</p>
<blockquote>
<p> Tailscale是一个基于 WireGuard 的 点对点网状 VPN (mesh VPN)，每台节点通过加密隧道直接互联，允许分布在不同网络、不同 NAT&#x2F;防火墙后的设备互联。</p>
</blockquote>
<ol>
<li><p>在每台服务器上（主库 + 从库 + 仲裁&#x2F;见证机）下载<code>Tailscale</code>执行下面的命令，然后登录同一个账号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://tailscale.com/install.sh | sh</span><br><span class="line">sudo tailscale up</span><br></pre></td></tr></table></figure>
<p>完成后每台机器会加入同一个 <code>Tailnet</code>，并分配一个 <code>Tailscale</code> <strong>私有 IP 地址</strong>（如 100.x.y.z）。</p>
</li>
<li><p>查看PostgreSQL监听的端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ss -ltnp | grep postgres</span><br></pre></td></tr></table></figure></li>
<li><p>测试机器之间能相互连通（至少主库能被 Standby 连通，仲裁节点也需要与主&#x2F;从连通）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试能连到主库的 5432 端口</span></span><br><span class="line">nc -zv &lt;PRIMARY_IP&gt; 5432</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>使用<code>Tailscale</code>后发现阿里云的<code>Workbench</code>一键连接会断开连接，转用<code>ssh</code>连接解决</p>
</blockquote>
<blockquote>
<p>在使用<code>tailscale</code>构建的虚拟局域网内，如果想要使用内网<code>ip</code>执行<code>scp</code>或者<code>rsync</code>命令，需要在开始时添加<code>--ssh</code>选项并登录账号进行授权：<code>sudo tailscale up --ssh</code></p>
</blockquote>
<h2 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h2><p>把 主库 <code>PostgreSQL</code>安装的 <strong>整个数据目录</strong>（包括系统库、所有用户库、配置、WAL 日志等） 拷贝到从库目标目录。它拉取的是 <code>PostgreSQL</code> 集群所有数据库和相关文件的物理拷贝。这样从库就可以基于这个拷贝启动，与主库同步进行复制。</p>
<blockquote>
<p>注意，默认状态下复制是异步的，若要开启同步复制，需要修改<code>postgresql.conf</code>的配置参数<code>synchronous_standby_names</code> 和 <code>synchronous_commit = on</code></p>
</blockquote>
<p><strong>1. 停止从库服务</strong>（确保数据目录没被占用）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres pg_ctl -D /usr/local/pgsql/data stop</span><br></pre></td></tr></table></figure>
<p><strong>2. 创建一个负责管理的Linux用户postgres</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser postgres</span><br><span class="line"></span><br><span class="line"><span class="comment">## 新加的用户没有sudo命令权限</span></span><br><span class="line">su -          <span class="comment"># 切换为 root</span></span><br><span class="line">usermod -aG sudo postgres <span class="comment"># 将 postgres 用户加入 sudoers 或 sudo 组</span></span><br><span class="line">su - postgres <span class="comment">#切换回来</span></span><br></pre></td></tr></table></figure>
<p><strong>3. 清空旧数据目录并重建</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres <span class="built_in">rm</span> -rf /usr/local/pgsql/data/*</span><br><span class="line">sudo -u postgres <span class="built_in">mkdir</span> -p /usr/local/pgsql/data</span><br><span class="line">sudo <span class="built_in">chown</span> -R postgres:postgres /usr/local/pgsql/data</span><br><span class="line">sudo <span class="built_in">chmod</span> 700 /usr/local/pgsql/data</span><br></pre></td></tr></table></figure>
<p><strong>4. 从主库拉取基础备份,实现物理复制初始化</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres pg_basebackup -h &lt;PRIMARY_IP&gt; -p 5432 -U replicator -D /usr/local/pgsql/data -Fp -Xs -P -R</span><br></pre></td></tr></table></figure>

<ul>
<li>-D 指定目标数据目录。</li>
<li>-Fp 指定格式为 “plain files”（默认格式，不压缩为 tar）。</li>
<li>-Xs 指定 <strong>WAL 文件通过流方式获取（stream）且包括相关 WAL</strong>。</li>
<li>-P 显示进度。</li>
<li>-R 指示自动创建恢复配置文件（比如 standby.signal 或 recovery.conf 根据 PostgreSQL 版本），使得该节点自动作为 standby 启动。</li>
</ul>
<p><code>pg_basebackup</code> 会提示输入 <code>replica_pass</code>（即在主库创建的 replicator 的密码）: <a href="#%E4%B8%BB%E5%BA%93%E9%85%8D%E7%BD%AE">replica_pass</a><br>执行成功后 <code>/usr/local/pssql/data </code>会包含主库的 <code>basebackup</code> 数据，并生成一个文件 <code>standby.signal</code>。  <code>postgresql.auto.conf</code> 文件中应该包含一行 <code>primary_conninfo = &#39;host=&lt;PRIMARY_IP&gt; port=5432 user=replicator password=...&#39;</code></p>
<blockquote>
<p>可能的报错：sudo: pg_basebackup: command not found，原因是sudo 会用一个受限的环境执行命令，没有继承用户的 PATH 。用绝对路径执行命令：<code>sudo -u postgres /usr/local/pgsql/bin/pg_basebackup -h &lt;PRIMARY_IP&gt; -p 5432 -U replicator -D /usr/local/pgsql/data -Fp -Xs -P -R</code></p>
</blockquote>
<p><strong>5. 在拉取完成后，启动从库</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres pg_ctl -D /usr/local/pgsql/data start</span><br></pre></td></tr></table></figure>
<blockquote>
<p>遇到了一个报错：<code>waiting for server to start....2025-10-28 17:45:57.797 CST [4539] FATAL: could not access file &quot;pg_stat_statements&quot;</code> 这是之前学习时在主库安装了拓展，从库没安装。安装方法：<code>cd /usr/local/src/postgresql-16.8/contrib</code> 执行<code>make</code> 然后<code>sudo make install</code></p>
</blockquote>
<h2 id="验证主从同步"><a href="#验证主从同步" class="headerlink" title="验证主从同步"></a>验证主从同步</h2><p><strong>在从库上查看 WAL 接收器状态</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_stat_wal_receiver;</span><br></pre></td></tr></table></figure>
<p>正常时会看到 <code>status = streaming</code> 和有相关连接信息<br>结果返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">pid  |  status   | receive_start_lsn | receive_start_tli | written_lsn | flushed_lsn | received_tli |      last_msg_send_time       |     last_msg_receipt_time     | latest_end_lsn |        latest_end_time        | slot</span><br><span class="line">_name |  sender_host  | sender_port |                                                                                                                                                                       conninfo        </span><br><span class="line">                                                                                                                                                                </span><br><span class="line">------+-----------+-------------------+-------------------+-------------+-------------+--------------+-------------------------------+-------------------------------+----------------+-------------------------------+-----</span><br><span class="line">------+---------------+-------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> 5583 | streaming | 0/13000000        |                 1 | 0/13000148  | 0/13000148  |            1 | 2025-10-28 18:05:01.389383+08 | 2025-10-28 18:05:01.507617+08 | 0/13000148     | 2025-10-28 18:01:27.806105+08 |     </span><br><span class="line">      | 100.89.48.112 |        5432 | user=replicator password=******** channel_binding=prefer dbname=replication host=100.89.48.112 port=5432 fallback_application_name=walreceiver sslmode=prefer sslcompression=0 sslcert</span><br><span class="line">mode=allow sslsni=1 ssl_min_protocol_version=TLSv1.2 gssencmode=disable krbsrvname=postgres gssdelegation=0 target_session_attrs=any load_balance_hosts=disable</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p><strong>试插入数据，验证主从同步</strong></p>
<ol>
<li>在主库创建测试表并插入记录（在主库 psql 执行）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres psql -d dvdrental -c <span class="string">&quot;CREATE TABLE test_ha(id serial primary key, note text);&quot;</span></span><br><span class="line">sudo -u postgres psql -d dvdrental -c <span class="string">&quot;INSERT INTO test_ha(note) VALUES (&#x27;from_primary&#x27;);&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或者执行，然后在psql执行SQL语句</span></span><br><span class="line">psql dvdrental</span><br><span class="line"></span><br><span class="line">CREATE TABLE test_ha(<span class="built_in">id</span> serial primary key, note text);</span><br><span class="line">INSERT INTO test_ha(note) VALUES (<span class="string">&#x27;from_primary&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在从库查询（注意：从库是 hot_standby，只能读）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres psql -d dvdrental -c <span class="string">&quot;SELECT * FROM test_ha;&quot;</span></span><br></pre></td></tr></table></figure>
<p>结果是能看到主库插入的数据。</p>
<h2 id="有关Linux用户和PostgreSQL用户的问题"><a href="#有关Linux用户和PostgreSQL用户的问题" class="headerlink" title="有关Linux用户和PostgreSQL用户的问题"></a>有关Linux用户和PostgreSQL用户的问题</h2><h3 id="Linux用户"><a href="#Linux用户" class="headerlink" title="Linux用户"></a>Linux用户</h3><p><strong>Linux 系统用户</strong>是操作系统层面的用户账号，比如 root、wqstage、postgres 等。它用于控制文件系统访问、进程启动、系统权限、登录操作等。OS 用户有用户名、UID（用户 ID）、所属群组、家目录、shell 等等。<br>当运行：<code>sudo -u wqstage psql …</code>命令时，只是操作系统的 “切换用户” 活动，而不是切换数据库角色。</p>
<p>值得注意的是：**<code>sudo</code> 命令默认会 重置或清除大部分环境变量，包括 PATH，以保证安全<strong>。当运行<code> sudo -u wqstage which psql</code> 时，该命令在一个新的环境下执行，此时 <code>PATH</code> 可能只包含标准系统路径（如 &#x2F;usr&#x2F;bin、&#x2F;bin）而不包含你源码安装的 <code>/usr/local/pgsql/bin</code>。因此，即便在普通登录 session 中设定了 <code>export PATH=/usr/local/pgsql/bin:$PATH</code>，但使用 <code>sudo</code> 切换用户时，这条 <strong><code>PATH</code> 设定未被继承或已被重置</strong> 。结果就是：直接登录 <code>wqstage</code> 使用源码安装的客户端正常；但 <code>sudo</code> 切换执行时却用了系统版本客户端，导致连接可能指向错误的 <code>PostgreSQL</code> 实例或 <code>socket</code> 路径，</strong>从而出现 “没有那个文件或目录” 的错误**。</p>
<h3 id="PostgreSQL角色"><a href="#PostgreSQL角色" class="headerlink" title="PostgreSQL角色"></a>PostgreSQL角色</h3><p>在 <code>PostgreSQL</code> 中，<strong>数据库用户</strong>其实是 “角色（role）” 的一种情况。一个角色如果被赋予 <code>LOGIN</code> 属性，就可以作为“用户”登录数据库。没有 <code>LOGIN</code> 的角色更像“组”或“权限集合”。角色拥有或被授予权限（如创建数据库、复制权限、表的所有者、连接权限等），并控制谁能访问哪个数据库、哪个表、执行何种操作。</p>
<p>数据库角色 不需要与 <code>OS</code> 用户名、UID 对应。容易混淆的是：在安装 <code>PostgreSQL</code> 时，系统自动创建 <code>OS</code> 用户 <code>postgres</code>，数据库也自动创建角色<code> postgres</code>。由于名称相同，人们容易误以为它们是同一个账号。事实上它们是不同层级的账号，但出于便利它们常被“配对”。</p>
<p><strong>连接默认行为</strong>：在 PostgreSQL 中，如果你使用 <code>Linux</code>用户 <code>wqstage</code> 登录系统，然后执行 <code>psql</code> 但未指定<code> -U</code> 参数，那么 <code>psql</code> 会尝试用角色名 <code>wqstage</code> 登录数据库。因为<strong>默认数据库用户名为当前 <code>OS</code> 用户名</strong>（例如 Linux 用户 wqstage）。正如文档指出：默认连接数据库名为当前 <code>OS</code> 用户。</p>
<h2 id="手动故障切换主从库"><a href="#手动故障切换主从库" class="headerlink" title="手动故障切换主从库"></a>手动故障切换主从库</h2><p><strong>1. 在从库上执行命令，将从库提升(promote)为新的主库</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres /usr/local/pgsql/bin/pg_ctl -D /usr/local/pgsql/data promote</span><br></pre></td></tr></table></figure>
<p>之后该从库成功 promotion，<strong>会成为可写的主库</strong>。可以验证其可写性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres psql -c <span class="string">&quot;CREATE TABLE promoted_test(id serial);&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 若要退回到未提升前的状态</strong><br>当你在某台从库上执行了 <code>pg_ctl promote</code> 让它成为新的主库后，<strong>原主库自动变不会成从库</strong>，可以手动将其作为从库重新加入集群</p>
<p><strong>使用<code>pg_rewind</code>工具进行回退流程：</strong><br>(这里原主库指虚拟机实例，新主库指阿里云的实例)<br>在原主库节点停止 <code>PostgreSQL</code> 服务： <code>pg_ctl stop</code><br>在新主库节点执行 <code>pg_rewind</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres /usr/local/pgsql/bin/pg_rewind \</span><br><span class="line">  -D /usr/local/pgsql/data \</span><br><span class="line">  --source-server=<span class="string">&quot;host=&lt;NEW_PRIMARY_IP&gt; port=5432 user=replicator password=replica_pass dbname=postgres&quot;</span></span><br></pre></td></tr></table></figure>
<p>在原主库的数据目录中 创建 <code>standby.signal</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres <span class="built_in">touch</span> /usr/local/pgsql/data/standby.signal</span><br></pre></td></tr></table></figure>
<p>编辑 <code>postgresql.auto.conf</code> 或 <code>postgresql.conf</code>，在其中加入或确认：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">primary_conninfo = <span class="string">&#x27;host=&lt;NEW_PRIMARY_IP&gt; port=5432 user=replicator password=replica_pass&#x27;</span></span><br><span class="line">recovery_target_timeline = <span class="string">&#x27;latest&#x27;</span></span><br></pre></td></tr></table></figure>
<p>最后启动从库就可以了。</p>
<blockquote>
<p>需要注意，使用<code>pg_rewind</code>工具,该工具需要开启 <code>wal_log_hints = on </code>才能生效， 是用来在 <code>WAL</code> 文件中添加额外的日志提示信息的。但是如果启用 <code>wal_log_hints = on</code> 这个设置是在某些 <code>WAL</code> 文件已经生成之后才启用的， 这些已经生成的 <code>WAL</code> 文件将没有 <code>wal_log_hints</code> 信息，因此 <code>pg_rewind</code> 可能无法识别和同步它们。就会报错<code>pg_rewind: error: target server needs to use either data checksums or &quot;wal_log_hints = on&quot;</code></p>
</blockquote>
<p>实在没办法可以使用另一种方法，那就是删从库再重新搭建主从，也就是重新执行之前的步骤<a href="#%E4%BB%8E%E5%BA%93%E9%85%8D%E7%BD%AE">从库搭建</a></p>
<hr>
<h1 id="使用repmgr工具实现主从同步和自动化故障切换"><a href="#使用repmgr工具实现主从同步和自动化故障切换" class="headerlink" title="使用repmgr工具实现主从同步和自动化故障切换"></a>使用<code>repmgr</code>工具实现主从同步和自动化故障切换</h1><p>通过<code>repmgr</code>实现自动化故障切换。<br><code>repmgr</code>(replication manager)是一套开源工具套件，用于管理 <code>PostgreSQL</code> 服务器集群中的复制和故障转移。它通过提供设置备用服务器、监控复制以及执行故障转移或手动切换操作等管理任务的工具，增强了内置的热备功能。</p>
<h2 id="安装repmgr"><a href="#安装repmgr" class="headerlink" title="安装repmgr"></a>安装<code>repmgr</code></h2><blockquote>
<p><strong>特别注意：如果使用源码安装的PostgreSQL，那么也使用源码安装repmgr，否则会导致&#x2F;usr&#x2F;local&#x2F;pgsql&#x2F;lib 缺失repmgr.so文件，导致一系列缺乏拓展的后果，非常严重！！！<br>同样，如果使用apt安装postgreSQL，那么也使用apt安装repmgr。</strong></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install postgresql-16-repmgr       <span class="comment"># 16：postgresql的版本</span></span><br></pre></td></tr></table></figure>
<h2 id="修改主库-postgresql-conf-文件"><a href="#修改主库-postgresql-conf-文件" class="headerlink" title="修改主库 postgresql.conf 文件"></a>修改主库 postgresql.conf 文件</h2><blockquote>
<p>最好不要在默认<code>postgresql.conf</code> 文件中编辑这些设置，而是创建一个单独的文件，例如<code>postgresql.replication.conf</code>，并将其从主配置文件的末尾包含进来，如下所示： <code>include &#39;postgresql.replication.conf&#39;</code>。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">max_wal_senders = 10</span><br><span class="line">max_replication_slots = 10</span><br><span class="line">wal_level = replica</span><br><span class="line">hot_standby = on</span><br><span class="line">archive_mode = on   <span class="comment"># repmgr 本身不需要 WAL 文件归档。</span></span><br><span class="line">archive_command = <span class="string">&#x27;/usr/local/src/archive&#x27;</span>      <span class="comment"># 需要自己创建文件夹</span></span><br><span class="line">wal_log_hints = on      <span class="comment">#如果打算使用pg_rewind，并且集群未使用数据校验和进行初始化，则需要考虑启用 </span></span><br></pre></td></tr></table></figure>
<h2 id="在主库实例上创建-repmgr-用户和数据库"><a href="#在主库实例上创建-repmgr-用户和数据库" class="headerlink" title="在主库实例上创建 repmgr 用户和数据库"></a>在主库实例上创建 repmgr 用户和数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> repmgr <span class="keyword">WITH</span> PASSWORD <span class="string">&#x27;repmgr_pass&#x27;</span> SUPERUSER;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE repmgr OWNER repmgr; </span><br></pre></td></tr></table></figure>
<h2 id="修改主库-pg-hba-conf-文件"><a href="#修改主库-pg-hba-conf-文件" class="headerlink" title="修改主库 pg_hba.conf 文件"></a>修改主库 pg_hba.conf 文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ vim pg_hba.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例ip</span></span><br><span class="line"><span class="built_in">local</span>   replication   repmgr                              trust</span><br><span class="line">host    replication   repmgr      100.119.50.59/32        trust</span><br><span class="line">host    replication   repmgr      0.0.0.0/0               trust</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span>   repmgr        repmgr                              trust</span><br><span class="line">host    repmgr        repmgr      100.119.50.59/32        trust</span><br><span class="line">host    repmgr        repmgr      0.0.0.0/0               trust</span><br></pre></td></tr></table></figure>

<h2 id="在主库上创建repmgr-conf-配置文件"><a href="#在主库上创建repmgr-conf-配置文件" class="headerlink" title="在主库上创建repmgr.conf 配置文件"></a>在主库上创建<code>repmgr.conf</code> 配置文件</h2><p><code>repmgr.conf</code>不应将其存储在 <code>PostgreSQL</code> 数据目录中，因为在设置或重新初始化 <code>PostgreSQL</code> 服务器时可能会被覆盖。<br><strong>可以放在<code>/etc/repmgr.conf</code>目录</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">node_id=1</span><br><span class="line">node_name=<span class="string">&#x27;node1&#x27;</span></span><br><span class="line">conninfo=<span class="string">&#x27;host=100.89.48.112 user=repmgr dbname=repmgr password=repmgr_pass connect_timeout=30&#x27;</span></span><br><span class="line">data_directory=<span class="string">&#x27;/usr/local/pgsql/data&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># failover设置(用于repmgrd)</span></span><br><span class="line">failover=automatic</span><br><span class="line">promote_command=<span class="string">&#x27;/usr/bin/repmgr -f /etc/repmgr.conf standby promote  --log-to-file&#x27;</span>      <span class="comment">#当 repmgrd 确定当前节点将成为新的主节点时 ，将在故障转移情况下执行 promote_command 中定义的程序或脚本                                     </span></span><br><span class="line">follow_command=<span class="string">&#x27;/usr/bin/repmgr -f /etc/repmgr.conf  standby follow --log-to-file --upstream-node-id=%n&#x27;</span>     <span class="comment"># %n将被替换 repmgrd与新的主节点的ID， 如果没有提供， repmgr standby follow将尝试自行确定新的主repmgr standby follow节点，</span></span><br><span class="line">                                                            <span class="comment"># 但如果在新主节点提升后原主节点重新上线，则存在导致节点继续跟随原主节点的风险 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示复制进度</span></span><br><span class="line">pg_basebackup_options = <span class="string">&#x27;-P&#x27;</span>  </span><br><span class="line"><span class="comment"># 高级设置</span></span><br><span class="line">monitoring_history=<span class="literal">true</span>       <span class="comment"># 是否将监控数据写入“monitoring_history”表</span></span><br><span class="line">monitor_interval_secs=10      <span class="comment"># 每隔 10 秒检测一次主库健康状态</span></span><br><span class="line">reconnect_attempts=8          <span class="comment"># 故障转移之前，尝试重新连接的次数</span></span><br><span class="line">reconnect_interval=5          <span class="comment"># 故障转移之前，尝试重新连接的间隔（以秒为单位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志设置</span></span><br><span class="line">log_level=INFO</span><br><span class="line">log_file=<span class="string">&#x27;/usr/log/repmgr/repmgrd.log&#x27;</span>      <span class="comment"># log 文件需要提前创建</span></span><br><span class="line">log_status_interval=300</span><br></pre></td></tr></table></figure>

<h2 id="注册主服务器"><a href="#注册主服务器" class="headerlink" title="注册主服务器"></a>注册主服务器</h2><p>要使 <code>repmgr</code> 支持复制集群，必须使用 <code>repmgr</code> 注册主节点（repmgr primary register）。这将安装<code>repmgr</code>的扩展和元数据对象，并为主服务器添加元数据记录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repmgr -f /etc/repmgr.conf primary register</span><br><span class="line"></span><br><span class="line"><span class="comment">#成功会出现以下信息</span></span><br><span class="line"><span class="comment">#INFO: connecting to primary database...</span></span><br><span class="line"><span class="comment">#NOTICE: attempting to install extension &quot;repmgr&quot;</span></span><br><span class="line"><span class="comment">#NOTICE: &quot;repmgr&quot; extension successfully installed</span></span><br><span class="line"><span class="comment">#NOTICE: primary node record (id: 1) registered</span></span><br></pre></td></tr></table></figure>

<p>注册后查看集群信息命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repmgr -f /etc/repmgr.conf cluster show</span><br></pre></td></tr></table></figure>

<h2 id="在从库上创建repmgr-conf配置文件"><a href="#在从库上创建repmgr-conf配置文件" class="headerlink" title="在从库上创建repmgr.conf配置文件"></a>在从库上创建<code>repmgr.conf</code>配置文件</h2><p>&#x2F;etc&#x2F;repmgr.conf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">node_id=2</span><br><span class="line">node_name=<span class="string">&#x27;node2&#x27;</span></span><br><span class="line">conninfo=<span class="string">&#x27;host=100.119.50.59 user=repmgr dbname=repmgr password=repmgr_pass connect_timeout=30&#x27;</span></span><br><span class="line">data_directory=<span class="string">&#x27;/usr/local/pgsql/data&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># failover设置</span></span><br><span class="line">failover=automatic</span><br><span class="line">promote_command=<span class="string">&#x27;/usr/bin/repmgr -f /etc/repmgr.conf standby promote  --log-to-file&#x27;</span>                                     </span><br><span class="line">follow_command=<span class="string">&#x27;/usr/bin/repmgr -f /etc/repmgr.conf  standby follow --log-to-file --upstream-node-id=%n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示复制进度</span></span><br><span class="line">pg_basebackup_options = <span class="string">&#x27;-P&#x27;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 高级设置</span></span><br><span class="line">monitoring_history=<span class="literal">true</span>       <span class="comment"># 是否将监控数据写入“monitoring_history”表</span></span><br><span class="line">monitor_interval_secs=10      <span class="comment"># 每隔 10 秒检测一次主库健康状态</span></span><br><span class="line">reconnect_attempts=8          <span class="comment"># 故障转移之前，尝试重新连接的次数</span></span><br><span class="line">reconnect_interval=5          <span class="comment"># 故障转移之前，尝试重新连接的间隔（以秒为单位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志设置</span></span><br><span class="line">log_level=INFO</span><br><span class="line">log_file=<span class="string">&#x27;/usr/log/repmgr/repmgrd.log&#x27;</span>      <span class="comment"># log 文件需要提前创建</span></span><br><span class="line">log_status_interval=300</span><br></pre></td></tr></table></figure>

<h2 id="克隆从库"><a href="#克隆从库" class="headerlink" title="克隆从库"></a>克隆从库</h2><p>在从库上，不要创建 <code>PostgreSQL</code> 实例（即不要执行 <code>initdb</code> 或任何包提供的数据库创建脚本），但要确保目标数据目录（以及希望 <code>PostgreSQL</code> 使用的任何其他目录）存在并归其所有 <code>postgres</code> 系统用户。权限必须设置为<code> 0700 (drwx------)</code>。<br>使用<code>--dry-run</code>测试是否具备复制的条件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repmgr -h 100.89.48.112 -U repmgr -d repmgr -f /etc/repmgr.conf standby <span class="built_in">clone</span> --dry-run</span><br></pre></td></tr></table></figure>
<p>没有问题的话直接执行就行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repmgr -h 100.89.48.112 -U repmgr -d repmgr -f /etc/repmgr.conf standby <span class="built_in">clone</span></span><br></pre></td></tr></table></figure>
<p>执行过程图如下：<br><img src="/../images/repmgr%20-P.png"></p>
<blockquote>
<p><code>repmgr standby clone</code> 是基于 <code>pg_basebackup</code> 来实现克隆的，原生 <code>pg_basebackup</code> 支持<code>-P</code>选项以显示复制进度</p>
</blockquote>
<p>如果报错需要密码，可以配置密码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># su postgres</span></span><br><span class="line">$ vim ~/.pgpass</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加以下内容到 ~/.pgpass 文件，用户、数据库和密码修改为自己的即可</span></span><br><span class="line"><span class="comment">#hostname:port:database:username:password</span></span><br><span class="line">100.89.48.112:5432:repmgr:repmgr:repmgr_pass</span><br><span class="line"><span class="comment"># 修改 ~/.pgpass 文件权限</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 600 ~/.pgpass</span><br></pre></td></tr></table></figure>

<h2 id="注册从库"><a href="#注册从库" class="headerlink" title="注册从库"></a>注册从库</h2><p>首先先启动从库<code>pg_ctl start</code></p>
<blockquote>
<p>这里遇到了一个问题，启动时报错<code>FATAL:  could not access file &quot;repmgr&quot;</code>，其实是因为通过<code>apt</code>安装的<code>repmgr</code>的默认库文件存放目录是<code>/usr/lib/postgresql/16/lib/repmgr.so</code>，而通过源码安装的<code>PostgreSQL</code> 的库文件在：<code>pg_config --pkglibdir</code> 显示的 <code>/usr/local/pgsql/lib</code>，可以直接<code>cp</code> <code>.so</code>文件过去来解决。</p>
</blockquote>
<p>验证复制功能是否正常(会显示一条记录)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> pg_stat_replication;</span><br></pre></td></tr></table></figure>
<p>没问题就可以注册从库啦：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repmgr -f /etc/repmgr.conf standby register</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者提供主服务器的连接参数：</span></span><br><span class="line"><span class="comment"># repmgr -f /etc/repmgr.conf standby register -h 100.119.50.59 -p 5432 -U repmgr -d repmgr</span></span><br></pre></td></tr></table></figure>

<p>同样可以查看注册信息：<code>repmgr -f /etc/repmgr.conf cluster show</code></p>
<h2 id="注册见证节点（witness）"><a href="#注册见证节点（witness）" class="headerlink" title="注册见证节点（witness）"></a>注册见证节点（witness）</h2><blockquote>
<p>官方文档：见证服务器的作用是在复制集群中的服务器分布在多个位置时提供“决定性投票”。如果不同位置之间的连接中断，见证服务器的存在与否将决定该位置的服务器是否被提升为主服务器；这样做是为了减少“脑裂”出现的概率，即某个孤立位置将网络中断解读为（远程）主服务器故障，从而提升（本地）备用服务器。</p>
</blockquote>
<p>发生故障转移的情况下，<strong>见证节点</strong>提供证据表明是主服务器本身是不可用的，而不是例如不同的物理位置之间的网络分离（<strong>防止脑裂问题出现</strong>） ，只有在使用 repmgrd 时，见证服务器才有用。<strong>它不能解决脑裂的出现，只能通过投票机制减少误切换，从而减少脑裂发生的概率。</strong><br>在与集群主服务器位于同一网段的服务器上设置一个普通 <code>PostgreSQL</code> 实例，此实例不应与主服务器位于同一物理主机上，否则，如果主服务器因硬件问题发生故障，见证服务器也会丢失。安装 <code>repmgr</code>、<code>repmgrd</code>，注册该实例为<code> witness</code>（repmgr witness register）</p>
<ol>
<li><p>启动节点 <code>postgres</code> 服务：<code>pg_ctl start</code></p>
</li>
<li><p>添加 <code>repmgr.conf</code> 配置，基本配置与主库相同，保持 <code>node_id</code>、<code>node_name</code>、<code>conninfo</code> 与主库不同即可。</p>
</li>
<li><p>修改 postgresql.conf 文件，加入repmgr 共享库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_preload_libraries = <span class="string">&#x27;passwordcheck, repmgr&#x27;</span></span><br></pre></td></tr></table></figure>
<p>连接数据库，执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> repmgr <span class="keyword">WITH</span> PASSWORD <span class="string">&#x27;repmgr_pass&#x27;</span> SUPERUSER;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE repmgr OWNER repmgr; </span><br><span class="line"></span><br><span class="line"># 在repmgr数据库执行添加拓展</span><br><span class="line"><span class="keyword">CREATE</span> EXTENSION repmgr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启数据库 <code>pg_ctl restart</code></p>
</li>
</ol>
<p><strong>5. 注册见证节点</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repmgr -h 100.89.48.112 -f /etc/repmgr.conf witness  register</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>启动 repmgrd<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repmgrd -f /etc/repmgr.conf start</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="启动-repmgrd-守护进程"><a href="#启动-repmgrd-守护进程" class="headerlink" title="启动 repmgrd 守护进程"></a>启动 repmgrd 守护进程</h2><p><code>repmgrd</code>（replication manager daemon）是一个管理和监控守护进程，它可以<strong>自动执行故障转移和更新备用节点以跟随新的主节点</strong>等操作，是自动化故障切换的核心。它在复制集群中的每个节点上运行。并提供有关每个备用节点状态的监控信息。</p>
<ol>
<li><p>要使用<code>repmgrd</code> ，必须在<code>postgresql.conf</code>进行配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shared_preload_libraries = <span class="string">&#x27;repmgr&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置从库的 <code>failover</code> 设置<br>已在上面步骤的 <a href="#%E5%9C%A8%E4%BB%8E%E5%BA%93%E4%B8%8A%E5%88%9B%E5%BB%BArepmgrconf%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">repmgr.conf</a> 配置过了</p>
</li>
<li><p>在主库、从库和见证节点上分别启动 <code>repmgrd</code> 进程</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repmgrd -f /etc/repmgr.conf start</span><br></pre></td></tr></table></figure></li>
<li><p>查看repmgrd是否已经在后台运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep repmgrd</span><br></pre></td></tr></table></figure></li>
<li><p>若需要重启</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 `<span class="built_in">cat</span> /tmp/repmgrd.pid`</span><br><span class="line">repmgrd -f /etc/repmgr.conf --daemonize</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="故障测试和rejoin"><a href="#故障测试和rejoin" class="headerlink" title="故障测试和rejoin"></a>故障测试和rejoin</h2><ol>
<li><p>关闭主库<code>node1</code></p>
</li>
<li><p>在从库<code>node2</code>执行 <code>repmgr -f /etc/repmgr.conf cluster show</code>可以看到原主库连接不上了，而一个从库<code>node2</code>被自动提升为<code>primary</code></p>
</li>
<li><p>如果<code>node1</code>恢复，可以选择将其作为从库重新加入集群<br>首先停止<code>node1</code>的postgreSQL服务<code>pg_ctl stop</code> ,然后使用repmgr的<code>rejoin</code>命令,若还是不行就得重新克隆从库了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repmgr -f /etc/repmgr.conf node rejoin -h 100.89.48.112 -U repmgr -d repmgr --force-rewind --verbose</span><br><span class="line"><span class="comment"># --force-rewind 其实就是在加入前执行pg_rewind来确保时间点一致</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>解决了一个问题，在执行rejoin命令时报错<code>ERROR: this node ahead of the rejoin target on the same timeline </code>，重启主库和从库的postgresql服务就好了。具体原因不确定，推测是因为多次切换主从导致时间点错误，通过重启触发了清理未完事务、生成新的 <code>timeline</code> 或 <code>checkpoint</code>，从而让本地和目标之间的时间点差异消除</p>
</blockquote>
</li>
</ol>
<h2 id="编写自动化-bash-脚本自动将恢复的节点加入"><a href="#编写自动化-bash-脚本自动将恢复的节点加入" class="headerlink" title="编写自动化 bash 脚本自动将恢复的节点加入"></a>编写自动化 bash 脚本自动将恢复的节点加入</h2><p>编写bash脚本实现rejoin的自动化，通过<code>crontab -e</code>设置每十分钟执行一次脚本，并未其设置为<strong>带锁模式</strong>，防止与上一轮重叠执行导致的逻辑混乱。减少了操作量实现故障消除的节点自动重新加入集群。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔十分钟执行</span></span><br><span class="line">*/10 * * * * /usr/bin/flock -n /tmp/auto_rejoin.lock /usr/local/src/auto_rejoin.sh &gt;&gt; /usr/local/src/rejoin.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ========== PostgreSQL 自动检测与 rejoin脚本 ==========</span></span><br><span class="line"><span class="comment"># 说明：检测掉线节点 -&gt; 停止服务 -&gt; 清空目录 -&gt; clone -&gt; rejoin</span></span><br><span class="line"><span class="comment"># =====================================================</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/local/pgsql/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">log</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(date &#x27;+[%Y-%m-%d %H:%M:%S]&#x27;)</span> - $*&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span> <span class="string">&quot;脚本开始执行&quot;</span></span><br><span class="line"><span class="comment"># 获取 cluster 状态</span></span><br><span class="line">REPMGR_CLUSTER_SHOW=$(repmgr -f <span class="string">&quot;<span class="variable">$REPMGR_CONF</span>&quot;</span> cluster show | grep -v <span class="string">&#x27;^WARNING&#x27;</span>)</span><br><span class="line">PRIMARY_LINE=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$REPMGR_CLUSTER_SHOW</span>&quot;</span> | grep -i <span class="string">&#x27;! running as primary&#x27;</span> || <span class="literal">true</span>)</span><br><span class="line">PGDATA=<span class="string">&quot;/usr/local/pgsql/data&quot;</span></span><br><span class="line">CLONE_TS_DIR=<span class="string">&quot;/mnt/ssd/pg_tablespace&quot;</span></span><br><span class="line">REPMGR_CONF=<span class="string">&quot;/etc/repmgr.conf&quot;</span></span><br><span class="line"></span><br><span class="line">pg_ctl -D <span class="string">&quot;PGDATA&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否有掉线的节点</span></span><br><span class="line">CURRENT_PRIMARY_IP=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$PRIMARY_LINE</span>&quot;</span> | grep -o <span class="string">&quot;host=[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*&quot;</span> | <span class="built_in">cut</span> -d<span class="string">&#x27;=&#x27;</span> -f2 || <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$CURRENT_PRIMARY_IP</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">log</span> <span class="string">&quot;没有节点掉线，一切正常&quot;</span></span><br><span class="line">    <span class="built_in">log</span> <span class="string">&quot;脚本退出&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">log</span> <span class="string">&quot;检测到节点掉线，当前 primary_ip = <span class="variable">$CURRENT_PRIMARY_IP</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> ping -c 1  <span class="string">&quot;<span class="variable">$CURRENT_PRIMARY_IP</span>&quot;</span> &amp;&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">log</span> <span class="string">&quot;本节点能连接到主库，开始执行恢复流程&quot;</span></span><br><span class="line">    <span class="comment"># 停止 PostgreSQL 服务</span></span><br><span class="line">    <span class="built_in">log</span> <span class="string">&quot;停止 PostgreSQL 服务 ...&quot;</span></span><br><span class="line">    <span class="keyword">if</span> pg_ctl -D <span class="string">&quot;<span class="variable">$PGDATA</span>&quot;</span> stop; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">log</span> <span class="string">&quot;成功关闭 PostgreSQL 服务&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">log</span> <span class="string">&quot;ERROR: 关闭 PostgreSQL 服务失败，退出脚本&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#首先尝试直接rejoin</span></span><br><span class="line">    MAX_REJOIN=10</span><br><span class="line">    count=1</span><br><span class="line">    <span class="keyword">while</span> [ <span class="variable">$count</span> -le <span class="variable">$MAX_REJOIN</span> ]; <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">log</span> <span class="string">&quot;尝试rejoin 第<span class="variable">$count</span>次&quot;</span></span><br><span class="line">            <span class="keyword">if</span> repmgr -f <span class="string">&quot;<span class="variable">$REPMGR_CONF</span>&quot;</span> -h <span class="string">&quot;<span class="variable">$CURRENT_PRIMARY_IP</span>&quot;</span> node rejoin -U repmgr -d repmgr --force-rewind; <span class="keyword">then</span></span><br><span class="line">                    <span class="built_in">log</span> <span class="string">&quot;rejoin成功，退出脚本&quot;</span></span><br><span class="line">                    <span class="built_in">exit</span> 0</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">log</span> <span class="string">&quot;rejoin 失败&quot;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            count=$(( count + <span class="number">1</span> ))</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">log</span> <span class="string">&quot;rejoin失败，重新clone后再rejoin&quot;</span></span><br><span class="line"><span class="comment"># 清空数据目录 &amp; tablespace 目录，重新clone</span></span><br><span class="line">    <span class="built_in">log</span> <span class="string">&quot;清空数据目录 <span class="variable">$PGDATA</span>/*&quot;</span></span><br><span class="line">    sudo <span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$PGDATA</span>&quot;</span>/*</span><br><span class="line">    <span class="built_in">log</span> <span class="string">&quot;清空 tablespace 目录 <span class="variable">$CLONE_TS_DIR</span>/*&quot;</span></span><br><span class="line">    sudo <span class="built_in">rm</span> -rf <span class="string">&quot;<span class="variable">$CLONE_TS_DIR</span>&quot;</span>/*</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多次尝试 clone</span></span><br><span class="line">    MAX_ATTEMPTS=15</span><br><span class="line">    attempt=1</span><br><span class="line">    SUCCESS_CLONE=0</span><br><span class="line">    <span class="keyword">while</span> [ <span class="variable">$attempt</span> -le <span class="variable">$MAX_ATTEMPTS</span> ]; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">log</span> <span class="string">&quot;尝试 clone 第 <span class="variable">$attempt</span> 次&quot;</span></span><br><span class="line">        <span class="keyword">if</span> repmgr -f <span class="string">&quot;<span class="variable">$REPMGR_CONF</span>&quot;</span> -h <span class="string">&quot;<span class="variable">$CURRENT_PRIMARY_IP</span>&quot;</span> -U repmgr -d repmgr standby <span class="built_in">clone</span>; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">log</span> <span class="string">&quot;clone 成功&quot;</span></span><br><span class="line">            SUCCESS_CLONE=1</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">log</span> <span class="string">&quot;clone 第 <span class="variable">$attempt</span> 次失败，等待10秒后重试&quot;</span></span><br><span class="line">            <span class="built_in">sleep</span> 10</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        attempt=$(( attempt + <span class="number">1</span> ))</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$SUCCESS_CLONE</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">log</span> <span class="string">&quot;ERROR: 所有 clone 尝试失败，退出脚本&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 再次rejoin从库</span></span><br><span class="line">    <span class="built_in">log</span> <span class="string">&quot;执行 rejoin 操作 ...&quot;</span></span><br><span class="line">    count=1</span><br><span class="line">    <span class="keyword">while</span> [ <span class="variable">$count</span> -le <span class="variable">$MAX_REJOIN</span> ]; <span class="keyword">do</span></span><br><span class="line">            <span class="built_in">log</span> <span class="string">&quot;尝试rejoin 第<span class="variable">$count</span>次&quot;</span></span><br><span class="line">            <span class="keyword">if</span> repmgr -f <span class="string">&quot;<span class="variable">$REPMGR_CONF</span>&quot;</span> -h <span class="string">&quot;<span class="variable">$CURRENT_PRIMARY_IP</span>&quot;</span> node rejoin -U repmgr -d repmgr --force-rewind; <span class="keyword">then</span></span><br><span class="line">                    <span class="built_in">log</span> <span class="string">&quot;rejoin成功，退出脚本&quot;</span></span><br><span class="line">                    <span class="built_in">exit</span> 0</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">log</span> <span class="string">&quot;rejoin 失败&quot;</span></span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">            count=$(( count + <span class="number">1</span> ))</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">log</span> <span class="string">&quot;脚本执行完毕&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">log</span> <span class="string">&quot;当前节点 尚未恢复到主库连接，跳过恢复流程&quot;</span></span><br><span class="line">    <span class="built_in">log</span> <span class="string">&quot;脚本结束&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 PostgreSQL</span></span><br><span class="line">        <span class="built_in">log</span> <span class="string">&quot;启动 PostgreSQL 服务 ...&quot;</span></span><br><span class="line">        <span class="keyword">if</span> pg_ctl -D <span class="string">&quot;<span class="variable">$PGDATA</span>&quot;</span> start; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">log</span> <span class="string">&quot;PostgreSQL 启动成功&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">log</span> <span class="string">&quot;ERROR: PostgreSQL 启动失败，退出脚本&quot;</span></span><br><span class="line">                <span class="built_in">exit</span> 1</span><br><span class="line">        <span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h2 id="repmgrd-的暂停"><a href="#repmgrd-的暂停" class="headerlink" title="repmgrd 的暂停"></a>repmgrd 的暂停</h2><p>如果需要调试或者其他什么原因想要暂停<code>repmgrd</code>守护服务，可以使用命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repmgr -f /etc/repmgr.conf daemon pause</span><br><span class="line"><span class="comment"># 查看守护是否暂停</span></span><br><span class="line">repmgr -f /etc/repmgr.conf daemon status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复</span></span><br><span class="line">repmgr -f /etc/repmgr.conf daemon unpause </span><br></pre></td></tr></table></figure>

<h2 id="关于-repmgr-conf-文件"><a href="#关于-repmgr-conf-文件" class="headerlink" title="关于 repmgr.conf 文件"></a>关于 repmgr.conf 文件</h2><ul>
<li><p>若修改了元数据关键参数（如 node_id, node_name, data_directory），需要在每个节点执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ repmgr primary register --force -f path/to/repmgr.conf</span><br><span class="line">$ repmgr standby register --force -f path/to/repmgr.conf</span><br><span class="line">$ repmgr witness register --force -f path/to/repmgr.conf -h primary_host</span><br></pre></td></tr></table></figure>
</li>
<li><p>若使用 repmgrd 守护进程并修改了其相关参数 → 重载或重启守护进程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl reload repmgrd</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="压测与性能分析"><a href="#压测与性能分析" class="headerlink" title="压测与性能分析"></a>压测与性能分析</h1><p>通过构建测试场景、采集性能指标、分析瓶颈并优化配置，验证 PostgreSQL 高可用集群的性能与稳定性。</p>
<h2 id="通过源码安装-sysbench"><a href="#通过源码安装-sysbench" class="headerlink" title="通过源码安装 sysbench"></a>通过源码安装 sysbench</h2><p>系统包版本的 <code>sysbench</code>（例如 apt 安装）只支持 <code>MySQL</code>。要想用于 <code>PostgreSQL</code>，需要通过源码安装，编译时启用 <code>PostgreSQL</code> 驱动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/mirrors/sysbench.git</span><br><span class="line"><span class="built_in">cd</span> sysbench</span><br><span class="line"></span><br><span class="line">./autogen.sh</span><br><span class="line">./configure --without-mysql --with-pgsql</span><br><span class="line">make -j4</span><br><span class="line">sudo make install</span><br><span class="line"><span class="comment">#验证是否成功</span></span><br><span class="line">sysbench --<span class="built_in">help</span> | grep pgsql</span><br></pre></td></tr></table></figure>
<h2 id="OLTP（在线事务处理）读写混合场景性能测试流程"><a href="#OLTP（在线事务处理）读写混合场景性能测试流程" class="headerlink" title="OLTP（在线事务处理）读写混合场景性能测试流程"></a>OLTP（在线事务处理）读写混合场景性能测试流程</h2><p><strong>1. 创建测试专用数据库和用户</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE sbtest;</span><br><span class="line">CREATE USER sbtestuser WITH PASSWORD &#x27;sbtestpass&#x27;;</span><br><span class="line">GRANT ALL PRIVILEGES ON DATABASE sbtest TO sbtestuser;</span><br></pre></td></tr></table></figure>
<p><strong>2. <code>prepare</code> 初始化测试数据</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=pgsql \</span><br><span class="line">  --pgsql-host=localhost \</span><br><span class="line">  --pgsql-port=5432 \</span><br><span class="line">  --pgsql-user=sbtestuser \</span><br><span class="line">  --pgsql-password=sbtestpass \</span><br><span class="line">  --pgsql-db=sbtest \</span><br><span class="line">  --tables=5 \</span><br><span class="line">  --table-size=10000 \</span><br><span class="line">  oltp_read_write prepare</span><br><span class="line"></span><br><span class="line"><span class="comment">## --tables=5 ：设置为5个table的测试</span></span><br><span class="line"><span class="comment">## --table-size=100000 ：每张table的生成测试数据条数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果报错FATAL: <code>sysbench.cmdline.call_command&#39; function failed: /usr/local/share/sysbench/oltp_common.lua:203: SQL error, errno = 0, state = &#39;42501&#39;: permission denied for schema public</code>，说明sbtestuser 用户 没有对数据库 sbtest 的 public 模式的创建表权限。添加即可：<code>psql sbtest</code>  然后 <code>GRANT ALL PRIVILEGES ON SCHEMA public TO sbtestuser;ALTER SCHEMA public OWNER TO sbtestuser;</code></p>
</blockquote>
<p><strong>3. <code>run</code> 运行压测</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=pgsql \</span><br><span class="line">  --pgsql-host=localhost \</span><br><span class="line">  --pgsql-port=5432 \</span><br><span class="line">  --pgsql-user=sbtestuser \</span><br><span class="line">  --pgsql-password=sbtestpass \</span><br><span class="line">  --pgsql-db=sbtest \</span><br><span class="line">  --threads=10 \</span><br><span class="line">  --time=60 \</span><br><span class="line">  oltp_read_write run</span><br><span class="line"></span><br><span class="line"><span class="comment">## --threads=10 ：压测发起线程数(并发连接)</span></span><br><span class="line"><span class="comment">## --time=60 ： 压测时长，单位秒 ， 如果设置events，则无需设置该时间</span></span><br><span class="line"><span class="comment">## oltp_read_write 读写混合模式</span></span><br></pre></td></tr></table></figure>
<p><strong>4. 测试结果及分析</strong><br><strong>测试报告：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Running the <span class="built_in">test</span> with following options:</span><br><span class="line">Number of threads: 10</span><br><span class="line">Initializing random number generator from current time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Initializing worker threads...</span><br><span class="line"></span><br><span class="line">Threads started!</span><br><span class="line"></span><br><span class="line">SQL statistics:</span><br><span class="line">    queries performed:</span><br><span class="line">        <span class="built_in">read</span>:                            574518       <span class="comment">#执行的读类 SQL（SELECT）</span></span><br><span class="line">        write:                           164123       <span class="comment">#写操作（INSERT、UPDATE、DELETE）</span></span><br><span class="line">        other:                           82087        <span class="comment">#比如 BEGIN, COMMIT 等事务控制语句</span></span><br><span class="line">        total:                           820728       <span class="comment">#总SQL语句数</span></span><br><span class="line">    transactions:                        41031  (683.68 per sec.)       <span class="comment">#事务总数和每秒执行数 TPS</span></span><br><span class="line">    queries:                             820728 (13675.39 per sec.)          <span class="comment">#每个事务大约执行 20 条 SQL（820728 ÷ 41031 ≈ 20）。QPS</span></span><br><span class="line"></span><br><span class="line">平均每秒执行约 1.36万条 SQL。</span><br><span class="line">    ignored errors:                      6      (0.10 per sec.)         <span class="comment">#测试中忽略的小错误</span></span><br><span class="line">    reconnects:                          0      (0.00 per sec.)         <span class="comment">#重连次数为0，没有掉线</span></span><br><span class="line"></span><br><span class="line">Throughput:       <span class="comment">##吞吐量</span></span><br><span class="line">    events/s (eps):                      683.6794           <span class="comment">#其实和TPS一样</span></span><br><span class="line">    time elapsed:                        60.0150s</span><br><span class="line">    total number of events:              41031</span><br><span class="line"></span><br><span class="line">Latency (ms):        <span class="comment">##延迟</span></span><br><span class="line">         min:                                    0.91</span><br><span class="line">         avg:                                   14.62</span><br><span class="line">         max:                                   95.29</span><br><span class="line">         95th percentile:                       21.89       <span class="comment">#95%的事务在21.89ms内完成</span></span><br><span class="line">         <span class="built_in">sum</span>:                               599845.84</span><br><span class="line"></span><br><span class="line">Threads fairness:       <span class="comment">##线程均衡</span></span><br><span class="line">    events (avg/stddev):           4103.1000/65.74</span><br><span class="line">    execution time (avg/stddev):   59.9846/0.00</span><br><span class="line">    <span class="comment">#每个线程执行的事务数差距很小（标准差 65.74）。所有线程运行时间几乎一致（很均匀，说明CPU调度正常）。</span></span><br></pre></td></tr></table></figure>
<p><strong>4. 编写bash脚本实现对不同并发数的压测</strong><br>使用前先prepare数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 脚本：在不同线程的情况下的压测</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/local/pgsql/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">LOGPATH=<span class="string">&quot;/usr/local/src/pg_sysbench.log&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(date &#x27;+[%Y-%m-%d %H:%M:%S]&#x27;)</span> &#x27;压测脚本开始执行&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> &#123;10,20,40,60,80,100&#125;; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;\n====================== 线程数：<span class="variable">$item</span> ======================\n&quot;</span> &gt;&gt; <span class="variable">$LOGPATH</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(date &#x27;+[%Y-%m-%d %H:%M:%S]&#x27;)</span>&quot;</span> &gt;&gt; <span class="variable">$LOGPATH</span></span><br><span class="line">    sysbench --db-driver=pgsql \</span><br><span class="line">    --pgsql-host=localhost \</span><br><span class="line">    --pgsql-user=sbtestuser \</span><br><span class="line">    --pgsql-password=sbtestpass \</span><br><span class="line">    --pgsql-db=sbtest \</span><br><span class="line">    --tables=5 --table-size=10000 \</span><br><span class="line">    --threads=<span class="variable">$item</span> --time=60 \</span><br><span class="line">    oltp_read_write run &gt;&gt; <span class="variable">$LOGPATH</span></span><br><span class="line">    <span class="built_in">sleep</span> 10s</span><br><span class="line">    </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(date &#x27;+[%Y-%m-%d %H:%M:%S]&#x27;)</span> &#x27;压测脚本执行完毕！&#x27;&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>5. <code>cleanup</code> 清理测试数据</strong></p>
<blockquote>
<p>sysbench clean up 仅删除 sbtest 数据库下的测试表</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sysbench \</span><br><span class="line">  --db-driver=pgsql \</span><br><span class="line">  --pgsql-host=localhost \</span><br><span class="line">  --pgsql-port=5432 \</span><br><span class="line">  --pgsql-user=sbtestuser \</span><br><span class="line">  --pgsql-password=sbtestpass \</span><br><span class="line">  --pgsql-db=sbtest \</span><br><span class="line">  oltp_read_write cleanup</span><br></pre></td></tr></table></figure>

<h2 id="关于压测时主从同步的问题"><a href="#关于压测时主从同步的问题" class="headerlink" title="关于压测时主从同步的问题"></a>关于压测时主从同步的问题</h2><p>在上面的报告上显示 pg默认安装不进行任何参数调整的情况下 qps能每秒10000+，我这还只是一个4核4G的虚拟机，配置高的话可能会更恐怖。在这种情况下主库产生 WAL 的速度会很快，主库产生的日志备库来不及应用，而主库又有<code>wal_keep_size</code>参数的限制，超过这个数量的日志就会被删除，所以lag越来越大的情况下备库需要的wal日志可能已经被主库删除了，造成主从断连。<br>此时如果使用 <code>repmgr -f /etc/repmgr.conf cluster show</code>查看状态会发现从库的<code>Upstream</code>是 <code>?primary</code>状态，其他显示正常,查看主库的日志可以发现一直在报错：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR:  requested WAL segment 000000030000000000000045 has already been removed</span><br><span class="line">STATEMENT:  START_REPLICATION 0/45000000 TIMELINE 3</span><br></pre></td></tr></table></figure>

<p>导致这种现象的原因大概率是因为网络不稳定，传输速度慢，网络传输瓶颈导致从库同步跟不上。</p>
<p>解决办法就是：如果主库开启了归档，直接在里面找到从库缺失的归档文件传给从库就可以。<br>具体方案有：</p>
<ul>
<li>将缺失的归档文件从archive复制到pg_wal</li>
<li>编辑从库的postgresql.conf文件，<code>restore_command = cp /usr/local/src/archive/%f %p</code>，然后通过NFS<strong>共享主库的归档目录</strong>，这样当从库缺少某个 WAL 文件时，它会执行 <code>restore_command</code> 里写的命令，从共享归档目录取这个文件。</li>
</ul>
<hr>
<h1 id="可视化监控"><a href="#可视化监控" class="headerlink" title="可视化监控"></a>可视化监控</h1><p>使用 Grafana + Prometheus + PostgreSQL Exporter 来实现可视化监控。</p>
<h2 id="PostgreSLQ-Explore"><a href="#PostgreSLQ-Explore" class="headerlink" title="PostgreSLQ Explore"></a>PostgreSLQ Explore</h2><p>从数据库中采集性能指标（连接数、TPS、缓存命中率等）并暴露给 Prometheus<br>(主从库都需要安装)</p>
<p><strong>1. 下载 exporter</strong>（prometheus-community 版本）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/prometheus-community/postgres_exporter/releases/download/v0.18.1/postgres_exporter-0.18.1.linux-amd64.tar.gz</span><br><span class="line">tar -xzf postgres_exporter-0.18.1.linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> postgres_exporter-0.18.1.linux-amd64</span><br><span class="line"><span class="built_in">mv</span> postgres_exporter /usr/local/bin/</span><br></pre></td></tr></table></figure>
<p><strong>2. 创建监控专用数据库用户</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER pgmon WITH PASSWORD <span class="string">&#x27;pgmon_pass&#x27;</span>;</span><br><span class="line">GRANT pg_monitor TO pgmon;</span><br></pre></td></tr></table></figure>
<p>配置<code>pg_hba.conf</code> 然后重载数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host    postgres        pgmon           100.89.48.112/32        trust</span><br></pre></td></tr></table></figure>
<p><strong>3. 启动 exporter</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DATA_SOURCE_NAME=<span class="string">&quot;postgresql://pgmon:pgmon_pass@100.89.48.112:5432/postgres?sslmode=disable&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">nohup</span> postgres_exporter --web.listen-address=<span class="string">&quot;:9187&quot;</span> &gt;&gt; /usr/local/src/pg_exporter.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认 <code>exporter</code> 端口是 9187，<code>Prometheus</code> 就会通过这个端口采集。</p>
</blockquote>
<h2 id="prometheus"><a href="#prometheus" class="headerlink" title="prometheus"></a>prometheus</h2><p>定期抓取 exporter 暴露的指标并保存为时序数据</p>
<p><strong>1. 下载</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/prometheus/prometheus/releases/download/v3.7.3/prometheus-3.7.3.linux-amd64.tar.gz</span><br><span class="line">tar -xzf prometheus-3.7.3.linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> prometheus-3.7.3.linux-amd64</span><br><span class="line"><span class="built_in">mv</span> prometheus promtool /usr/local/bin/</span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/local/prometheus/&#123;data,conf&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 启动</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> prometheus --config.file=/usr/local/prometheus/conf/prometheus.yml \</span><br><span class="line">  --storage.tsdb.path=/usr/local/prometheus/data \</span><br><span class="line">  --web.listen-address=<span class="string">&quot;:9090&quot;</span> \</span><br><span class="line">  &gt;&gt; /usr/local/src/prometheus.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># nohup 进程关闭时保持终端不会关闭</span></span><br><span class="line"><span class="comment"># &amp; 后台运行</span></span><br></pre></td></tr></table></figure>
<p>默认端口9090，访问 Prometheus WebUI: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://&lt;监控机IP&gt;:9090</span><br></pre></td></tr></table></figure>
<h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p>从 Prometheus 查询数据并可视化展示、配置告警</p>
<p><strong>1. 安装启动</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.grafana.com/oss/release/grafana-12.2.1.linux-amd64.tar.gz</span><br><span class="line">tar -zxvf grafana-12.2.1.linux-amd64.tar.gz</span><br><span class="line"><span class="built_in">cd</span> grafana-12.2.1</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line"><span class="built_in">nohup</span> ./bin/grafana-server --homepath $(<span class="built_in">pwd</span>) &gt;&gt; /usr/local/src/grafana.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p><strong>2. 访问控制台</strong><br>Grafana的默认监听端口是 3000，，使用浏览器访问控制台：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://&lt;你的服务器IP&gt;:3000</span><br></pre></td></tr></table></figure>
<p>默认账号&#x2F;密码：admin &#x2F; admin。</p>
<p><strong>3. 添加 Prometheus 数据源</strong><br>在 <code>Grafana</code> 控制台中：<br>导航路径：Connections → Data sources → Add data source → Prometheus<br>填写 URL: <code>http://l00.89.48.112:9090</code></p>
<p><strong>4. 自定义监控面板</strong><br>Grafana 社区已有成熟模板。在 Grafana → Dashboards → Import 中输入以下 ID：</p>
<table>
<thead>
<tr>
<th>Dashboard 名称</th>
<th>ID</th>
</tr>
</thead>
<tbody><tr>
<td>PostgreSQL Overview (by prometheus)</td>
<td><strong>9628</strong></td>
</tr>
<tr>
<td>PostgreSQL Instance Detail</td>
<td><strong>455</strong></td>
</tr>
</tbody></table>
<p>然后点击Load→ 选择数据源（Prometheus）→ 保存。<br>455仪表盘如图所示：</p>
<p><img src="/../images/grafana1.png"></p>
<h2 id="异常自动警告"><a href="#异常自动警告" class="headerlink" title="异常自动警告"></a>异常自动警告</h2><p>在<code>Grafana</code> 的<code>Altering</code> 设置ALter规则，实现性能异常或节点掉线时自动向飞书发出警告。实现方法是在飞书群组内设置自定义<code>webhook</code>机器人，在主库安装<code>PrometheusAlert</code>——一个开源的运维告警中心消息转发系统，将从<code>Grafana</code>发送的警告信息转发到飞书<code>webhook</code>机器人。</p>
<p><strong>1. 部署 PrometheusAlert</strong><br>首先安装运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/feiyu563/PrometheusAlert/releases/download/v4.9.1/linux.zip </span><br><span class="line">unzip linux.zip </span><br><span class="line"><span class="built_in">cd</span> linux/</span><br><span class="line"></span><br><span class="line"><span class="comment">#运行PrometheusAlert</span></span><br><span class="line">./PrometheusAlert (<span class="comment">#后台运行请执行 nohup ./PrometheusAlert &amp;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动后可使用浏览器打开以下地址查看：http://127.0.0.1:8080 或者 http://localhost:8080</span></span><br><span class="line"><span class="comment">#默认登录帐号和密码在app.conf中有配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 supervisor 来守护启动。</span></span><br><span class="line"><span class="comment"># 配置参考 example/supervisor/prometheusalert.ini</span></span><br><span class="line"><span class="comment"># 如果需要将日志输出到控制台，请修改 app.conf 中 logtype=console</span></span><br></pre></td></tr></table></figure>

<p>然后编辑conf&#x2F;app.config文件，开启飞书告警通道，并设置飞书群机器人的webhook地址(地址在飞书群组创建机器人时会给,只有pc客户端才可以)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim app.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#是否开启飞书告警通道,可同时开始多个通道0为关闭,1为开启</span></span><br><span class="line">open-feishu=1</span><br><span class="line"><span class="comment">#默认飞书机器人地址</span></span><br><span class="line">fsurl=https://open.feishu.cn/open-apis/bot/v2/hook/aa02d5c1-c936-430a-a62a-05225a5df3c0</span><br></pre></td></tr></table></figure>

<p><strong>2. 在 Grafana 配置警告联络点(contact points)</strong><br>添加一个新的联络点，配置名称和URL，注意此处的URL地址需要去<code>PrometheusAlert</code>的模版页面(浏览器内打开<a href="http://localhost:8080)获取，如发送给飞书的`grafana`模版:`http://100.89.48.112:8080/prometheusalert?type=fs&tpl=grafana-fs&fsurl=飞书机器人地址`">http://localhost:8080)获取，如发送给飞书的`grafana`模版:`http://100.89.48.112:8080/prometheusalert?type=fs&amp;tpl=grafana-fs&amp;fsurl=飞书机器人地址`</a><br>经过Test后能够正常发出警告就可以保存了。</p>
<p><strong>3. 在 Grafana 配置警报规则</strong><br>示例设置连接数监控：<br>首先在<code>Metric </code>选择 <code>pg_stat_activity_count</code>选项，然后在<code>Alert condition</code>部分设置<code>WHEN query (A) IS ABOVE 200</code>，即连接数超过200就告警，可以点击<code>Preview alert rule condition”</code> 进行测试。接着在<code>Add folder and labels</code>给规则打标签或分类，方便管理。再任何在<code>Set evaluation behavior</code>（评估频率）这一部分控制“多久检测一次”和“多久后才触发”。最后设置刚刚配置的<code>contact points</code>就完成了。</p>
<p><img src="/../images/grafana2.png"></p>
<p>最后展示在飞书上告警的结果：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/../images/%E9%A3%9E%E4%B9%A6webhook.png"></h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DBA/" rel="tag">DBA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Postgre/" rel="tag">Postgre</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag">项目</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
    
      <a href="/2025/10/24/%E6%85%A2%E6%9F%A5%E8%AF%A2/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">慢查询</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2025
        <i class="ri-heart-fill heart_icon"></i> Hexo
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/smile-circle-side.svg" alt="24stage"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2023/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>