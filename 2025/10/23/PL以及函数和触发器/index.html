<!DOCTYPE html>


<html lang="zh-hans">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="24stage Blog" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>PL以及函数和触发器 |  24stage</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/smile.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-PL以及函数和触发器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  PL以及函数和触发器
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2025/10/23/PL%E4%BB%A5%E5%8F%8A%E5%87%BD%E6%95%B0%E5%92%8C%E8%A7%A6%E5%8F%91%E5%99%A8/" class="article-date">
  <time datetime="2025-10-23T03:49:21.000Z" itemprop="datePublished">2025-10-23</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">2.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">9 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="PL-pgSQL"><a href="#PL-pgSQL" class="headerlink" title="PL&#x2F;pgSQL"></a>PL&#x2F;pgSQL</h1><p>PL&#x2F;pgSQL (Procedural Language&#x2F;PostgreSQL) 是 PostgreSQL 自带的 <strong>过程式语言</strong>，用于在数据库中编写函数、存储过程、触发器等逻辑。它让 SQL 具备“编程能力”——支持 变量、条件判断、循环、异常捕获 等控制流。</p>
<blockquote>
<p>SQL被PostgreSQL和大多数其他关系数据库用作查询语言。它是可移植的并且容易学习,但是每一个SQL语句必须由数据库服务器单独执行。这意味着你的客户端应用必须发送每一个查询到数据库服务器、等待它被处理、接收并处理结果、做一些计算，然后发送更多查询给服务器。如果你的客户端和数据库服务器不在同一台机器上，所有这些会引起进程间通信并且将带来网络负担。而通过PL&#x2F;pgSQL，你可以将一整块计算和一系列查询<strong>分组在数据库服务器内部</strong>，这样就有了一种过程语言的能力并且使 SQL 更易用，同时减少了很多的客户端&#x2F;服务器通信开销，能够带来可观的性能提升。</p>
</blockquote>
<h2 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h2><p>一个典型的 PL&#x2F;pgSQL 函数结构如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> 函数名(参数名 类型, ...)</span><br><span class="line"><span class="keyword">RETURNS</span> 返回类型 <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    <span class="comment">-- 声明变量</span></span><br><span class="line">    total_count <span class="type">INTEGER</span> :<span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 主体部分</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> total_count <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 条件判断</span></span><br><span class="line">    IF total_count <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">THEN</span></span><br><span class="line">        RAISE NOTICE <span class="string">&#x27;High salary employees: %&#x27;</span>, total_count;</span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        RAISE NOTICE <span class="string">&#x27;Few high salary employees&#x27;</span>;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">RETURN</span> total_count;</span><br><span class="line">EXCEPTION</span><br><span class="line">    <span class="keyword">WHEN</span> others <span class="keyword">THEN</span></span><br><span class="line">        RAISE NOTICE <span class="string">&#x27;Error occurred: %&#x27;</span>, SQLERRM;</span><br><span class="line">        <span class="keyword">RETURN</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>

<h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    myvar <span class="type">INTEGER</span> :<span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    emp_name TEXT;</span><br><span class="line">    emp_record RECORD;</span><br></pre></td></tr></table></figure>
<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp_name :<span class="operator">=</span> <span class="string">&#x27;Tom&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IF <span class="keyword">condition</span> <span class="keyword">THEN</span></span><br><span class="line">    <span class="comment">-- 语句</span></span><br><span class="line">ELSIF other_condition <span class="keyword">THEN</span></span><br><span class="line">    <span class="comment">-- 语句</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">    <span class="comment">-- 语句</span></span><br><span class="line"><span class="keyword">END</span> IF;</span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p><strong>FOR循环：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="number">1.</span><span class="number">.10</span> LOOP</span><br><span class="line">    RAISE NOTICE <span class="string">&#x27;Number: %&#x27;</span>, i;</span><br><span class="line"><span class="keyword">END</span> LOOP;</span><br></pre></td></tr></table></figure>

<p><strong>查询循环:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> emp_rec <span class="keyword">IN</span> <span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> employees LOOP</span><br><span class="line">    RAISE NOTICE <span class="string">&#x27;Employee: %, %&#x27;</span>, emp_rec.id, emp_rec.name;</span><br><span class="line"><span class="keyword">END</span> LOOP;</span><br></pre></td></tr></table></figure>
<p><strong>WHILE循环:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE total <span class="operator">&lt;</span> <span class="number">100</span> LOOP</span><br><span class="line">    total :<span class="operator">=</span> total <span class="operator">+</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">END</span> LOOP;</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">1</span> <span class="operator">/</span> <span class="number">0</span>;</span><br><span class="line">EXCEPTION</span><br><span class="line">    <span class="keyword">WHEN</span> division_by_zero <span class="keyword">THEN</span></span><br><span class="line">        RAISE NOTICE <span class="string">&#x27;Cannot divide by zero&#x27;</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="函数和存储过程"><a href="#函数和存储过程" class="headerlink" title="函数和存储过程"></a>函数和存储过程</h1><p>在 <code>PostgreSQL</code> 中，函数和过程封装了数据库中可重用的逻辑，以提升性能并维护数据结构。</p>
<blockquote>
<p>注意函数和过程的代码都放在 <code>AS $$ ....$$</code>之中。</p>
</blockquote>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>函数</strong>是 PostgreSQL 中最常用的可编程对象，它是<strong>可复用的 SQL 逻辑块</strong>，函数返回一个值或一个表，接受输入参数，在 SQL 查询、触发器、存储过程、甚至视图中都能调用。其定义方式为<code>CREATE FUNCTION</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">## 创建函数</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> add_two(a <span class="type">INT</span>, b <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span> </span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">RETURN</span> a <span class="operator">+</span> b;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br><span class="line"></span><br><span class="line">## 函数调用</span><br><span class="line"><span class="keyword">SELECT</span> add_two(<span class="number">3</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p><strong>过程</strong>是<code> PostgreSQL 11</code> 中引入的，它<strong>不返回值</strong>，但可以显式控制事务（提交&#x2F;回滚），例如<code>COMMIT</code>和<code>ROLLBACK</code>，其定义方式为<code>CREATE PROCEDURE</code>，并使用<code>CALL</code>语句调用。主要区别在于函数必须返回值并集成到 SQL 查询中，而过程则专注于执行操作和管理事务。</p>
<blockquote>
<p>过程用于执行动作，而非计算结果。<br>通常用于批处理、数据迁移、管理任务。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">## 创建过程</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> delete_user(uid <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">LANGUAGE</span> plpgsql</span><br><span class="line"><span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> uid;</span><br><span class="line">    <span class="keyword">COMMIT</span>;     ##可以显式<span class="keyword">COMMIT</span></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$;</span><br><span class="line"></span><br><span class="line">## 过程调用</span><br><span class="line"><span class="keyword">CALL</span> delete_user(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h2 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h2><table>
<thead>
<tr>
<th>项目</th>
<th>函数（Function）</th>
<th>过程（Procedure）</th>
</tr>
</thead>
<tbody><tr>
<td>是否有返回值</td>
<td>必须有（可为 void）</td>
<td>可无返回值</td>
</tr>
<tr>
<td>调用方式</td>
<td><code>SELECT func()</code></td>
<td><code>CALL proc()</code></td>
</tr>
<tr>
<td>事务控制</td>
<td>不能显式 commit&#x2F;rollback</td>
<td>可显式 commit&#x2F;rollback</td>
</tr>
<tr>
<td>使用场景</td>
<td>查询、计算、返回数据</td>
<td>批量修改、管理任务</td>
</tr>
</tbody></table>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器是一种<strong>事件驱动机制</strong>。当某张表发生 INSERT、UPDATE、DELETE、TRUNCATE 等操作时，会自动调用一个触发器函数。</p>
<blockquote>
<p>触发器函数其实也是 PL&#x2F;pgSQL 函数，只是返回类型是 TRIGGER。</p>
</blockquote>
<h2 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">## 定义触发器函数</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> trigger_func_name()</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">-- 操作逻辑</span></span><br><span class="line">    <span class="keyword">RETURN</span> <span class="keyword">NEW</span>;  <span class="comment">-- 对INSERT/UPDATE 返回NEW，对DELETE返回OLD</span></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br><span class="line"></span><br><span class="line">##定义触发器</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名</span><br><span class="line">&#123;BEFORE<span class="operator">|</span>AFTER<span class="operator">|</span>INSTEAD <span class="keyword">OF</span>&#125; &#123;<span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span>&#125;</span><br><span class="line"><span class="keyword">ON</span> 表名</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> trigger_func_name();</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>自动更新时间戳：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> update_modified_column()</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    NEW.updated_at :<span class="operator">=</span> now();</span><br><span class="line">    <span class="keyword">RETURN</span> <span class="keyword">NEW</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> set_update_time</span><br><span class="line">BEFORE <span class="keyword">UPDATE</span> <span class="keyword">ON</span> employees</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">FUNCTION</span> update_modified_column();</span><br></pre></td></tr></table></figure>
<p>每当 employees 表的行被更新时，updated_at 字段自动更新为当前时间。</p>
<hr>
<h1 id="递归CET"><a href="#递归CET" class="headerlink" title="递归CET"></a>递归CET</h1><p><strong>递归 CTE</strong> 是 CTE(通用表表达式)的一种特殊形式，用于查询层级结构数据（树&#x2F;图）。<br>它的特点是：子查询自己调用自己（递归定义），PostgreSQL 会自动不断重复执行，直到没有新行产生。</p>
<h2 id="语法结构-1"><a href="#语法结构-1" class="headerlink" title="语法结构"></a>语法结构</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> cte_name <span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">--  锚点查询（初始层）</span></span><br><span class="line">    <span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> ... <span class="keyword">WHERE</span> ...  <span class="comment">-- 基础数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span>   ## 合并所有层级结果（<span class="keyword">ALL</span> 保留重复）</span><br><span class="line"></span><br><span class="line">    <span class="comment">--  递归部分（自引用）</span></span><br><span class="line">    <span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> cte_name <span class="keyword">JOIN</span> ... <span class="keyword">ON</span> ...</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cte_name;</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>假设有一张表 <code>employees</code>：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>manager_id</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Alice</td>
<td>NULL</td>
</tr>
<tr>
<td>2</td>
<td>Bob</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>Carol</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>David</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>Erin</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>Frank</td>
<td>4</td>
</tr>
</tbody></table>
<p>现在要求查询 Alice 管理下的所有下属（不限层级）<br>查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> emp_hierarchy <span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">-- 锚点层：找到起始经理</span></span><br><span class="line">    <span class="keyword">SELECT</span> id, name, manager_id, <span class="number">1</span> <span class="keyword">AS</span> level</span><br><span class="line">    <span class="keyword">FROM</span> employees</span><br><span class="line">    <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 递归层：找下属</span></span><br><span class="line">    <span class="keyword">SELECT</span> e.id, e.name, e.manager_id, h.level <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">FROM</span> employees e</span><br><span class="line">    <span class="keyword">JOIN</span> emp_hierarchy h <span class="keyword">ON</span> e.manager_id <span class="operator">=</span> h.id     ##emp_hierarchy h 可以理解为当前递归已经找到的“上级员工”</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp_hierarchy;</span><br></pre></td></tr></table></figure>
<p>从 Alice 出发，层层向下找到所有员工，并记录层级深度，递归查询会持续执行 JOIN，直到没有新的子节点。查询结果如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>manager_id</th>
<th>level</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Alice</td>
<td>NULL</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>Bob</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>Carol</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>David</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>Erin</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>6</td>
<td>Frank</td>
<td>4</td>
<td>4</td>
</tr>
</tbody></table>
<hr>
<h1 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h1><p><strong>窗口函数</strong> 是一种在 SQL 查询中“跨多行计算但不合并行”的函数。<br>它不会像<code> GROUP BY</code> 那样聚合结果到单行，而是保留每行，并能在每行上计算“窗口”内的统计或排序信息。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function_name(expression) <span class="keyword">OVER</span> (</span><br><span class="line">    [<span class="keyword">PARTITION</span> <span class="keyword">BY</span> partition_expression]</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> sort_expression]</span><br><span class="line">    [<span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> frame_start <span class="keyword">AND</span> frame_end]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>over</code>:标识这是一个窗口函数</li>
<li><code>PARTITION BY</code>：定义分区，即窗口划分（类似 GROUP BY，但不折叠行）。  </li>
<li><code>ORDER BY</code>：定义窗口内行的逻辑顺序（影响排名、累积等）。  </li>
<li><code>ROWS BETWEEN</code>：定义窗口的行范围（例如前 2 行到当前行），常用的类型：<code>ROWS</code>, <code>RANGE</code>, <code>GROUPS</code>。</li>
</ul>
<h3 id="常见窗口函数与用途"><a href="#常见窗口函数与用途" class="headerlink" title="常见窗口函数与用途"></a>常见窗口函数与用途</h3><ul>
<li><strong>排名类</strong>：<code>ROW_NUMBER()</code>, <code>RANK()</code>, <code>DENSE_RANK()</code>。  </li>
<li><strong>偏移类</strong>：<code>LAG(expr, offset, default)</code>, <code>LEAD(expr, offset, default)</code>。  </li>
<li><strong>窗口聚合</strong>：<code>SUM()</code>, <code>AVG()</code>, <code>COUNT()</code> 等可作为窗口函数使用。  </li>
<li><strong>FIRST_VALUE &#x2F; LAST_VALUE</strong>：获取窗口内首&#x2F;末值。</li>
</ul>
<h3 id="FRAME-子句详解（关键）"><a href="#FRAME-子句详解（关键）" class="headerlink" title="FRAME 子句详解（关键）"></a>FRAME 子句详解（关键）</h3><ul>
<li>语法（示例）：<code>ROWS BETWEEN 2 PRECEDING AND CURRENT ROW</code> 或 <code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>。  </li>
<li><strong>ROWS</strong>：基于物理行数，例如“前 2 行到当前行”。  </li>
<li><strong>RANGE</strong>：基于值范围（对 ORDER BY 列的值相等或范围判断），在含有相同 ORDER BY 值时区别明显。  </li>
<li><strong>默认行为</strong>：如果指定了 <code>ORDER BY</code> 但未指定 <code>frame_clause</code>，PostgreSQL 默认的窗口帧通常是 <code>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code></li>
</ul>
<h2 id="窗口函数-与-GROUP-BY-的对比"><a href="#窗口函数-与-GROUP-BY-的对比" class="headerlink" title="窗口函数 与 GROUP BY 的对比"></a>窗口函数 与 GROUP BY 的对比</h2><h3 id="核心差别"><a href="#核心差别" class="headerlink" title="核心差别"></a>核心差别</h3><ul>
<li><strong>行为</strong>：<code>GROUP BY</code> 会把多行“压缩”成每个分组一行；<code>OVER</code> 会<strong>保留所有原始行</strong>，并为每行附加窗口计算结果。  </li>
<li><strong>用途</strong>：<code>GROUP BY</code> 用于生成分组级统计（报告&#x2F;汇总）；<code>OVER</code> 用于在明细行上做分析（排名、累加、分区统计等）。</li>
<li><strong>在 SELECT 中的限制</strong>：使用 <code>GROUP BY</code> 时，SELECT 中出现的非聚合列必须出现在 GROUP BY 子句中；而 <code>OVER</code> 可以在SELECT中与普通列并存。</li>
</ul>
<h3 id="执行顺序相关"><a href="#执行顺序相关" class="headerlink" title="执行顺序相关"></a>执行顺序相关</h3><ul>
<li>查询执行顺序（与 GROUP BY, HAVING, OVER 相关）通常是：<br><code>FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT (包括窗口函数计算) -&gt; ORDER BY -&gt; LIMIT</code>。  </li>
<li>换句话说，窗口函数（OVER）在分组&#x2F;聚合之后计算，因此可以访问分组聚合的结果，但不能出现在 WHERE 或 GROUP BY 或 HAVING 子句中。</li>
</ul>
<h3 id="示例数据（employees）"><a href="#示例数据（employees）" class="headerlink" title="示例数据（employees）"></a>示例数据（employees）</h3><table>
<thead>
<tr>
<th>name</th>
<th>department</th>
<th>salary</th>
</tr>
</thead>
<tbody><tr>
<td>Alice</td>
<td>HR</td>
<td>5000</td>
</tr>
<tr>
<td>Bob</td>
<td>HR</td>
<td>6000</td>
</tr>
<tr>
<td>Carol</td>
<td>IT</td>
<td>7000</td>
</tr>
<tr>
<td>David</td>
<td>IT</td>
<td>8000</td>
</tr>
<tr>
<td>Eve</td>
<td>Sales</td>
<td>4000</td>
</tr>
<tr>
<td>Frank</td>
<td>Sales</td>
<td>4500</td>
</tr>
</tbody></table>
<p><strong>示例 A — 使用 GROUP BY（部门级平均工资）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> dept_avg, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> cnt</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong></p>
<table>
<thead>
<tr>
<th>department</th>
<th>dept_avg</th>
<th>cnt</th>
</tr>
</thead>
<tbody><tr>
<td>HR</td>
<td>5500</td>
<td>2</td>
</tr>
<tr>
<td>IT</td>
<td>7500</td>
<td>2</td>
</tr>
<tr>
<td>Sales</td>
<td>4250</td>
<td>2</td>
</tr>
</tbody></table>
<p><strong>说明</strong>：每个部门只有一行（分组级别）。</p>
<p><strong>示例 B — 使用窗口函数（在每一行展示部门平均工资）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, department, salary,</span><br><span class="line">       <span class="built_in">AVG</span>(salary) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department) <span class="keyword">AS</span> dept_avg,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department) <span class="keyword">AS</span> dept_count</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> department, salary;</span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong></p>
<table>
<thead>
<tr>
<th>name</th>
<th>department</th>
<th>salary</th>
<th>dept_avg</th>
<th>dept_count</th>
</tr>
</thead>
<tbody><tr>
<td>Alice</td>
<td>HR</td>
<td>5000</td>
<td>5500</td>
<td>2</td>
</tr>
<tr>
<td>Bob</td>
<td>HR</td>
<td>6000</td>
<td>5500</td>
<td>2</td>
</tr>
<tr>
<td>Carol</td>
<td>IT</td>
<td>7000</td>
<td>7500</td>
<td>2</td>
</tr>
<tr>
<td>David</td>
<td>IT</td>
<td>8000</td>
<td>7500</td>
<td>2</td>
</tr>
<tr>
<td>Eve</td>
<td>Sales</td>
<td>4000</td>
<td>4250</td>
<td>2</td>
</tr>
<tr>
<td>Frank</td>
<td>Sales</td>
<td>4500</td>
<td>4250</td>
<td>2</td>
</tr>
</tbody></table>
<p><strong>说明</strong>：明细行保留，同时每行多出分组统计列。</p>
<h3 id="什么时候用哪一个？"><a href="#什么时候用哪一个？" class="headerlink" title="什么时候用哪一个？"></a>什么时候用哪一个？</h3><ul>
<li>只需要分组汇总（行折叠） → 使用 <code>GROUP BY</code>（更语义清晰，通常更高效）。  </li>
<li>需要按明细行显示并且同时显示分组统计 → 使用 <code>OVER</code>（保留明细并做分析）。</li>
</ul>
<h3 id="性能提示"><a href="#性能提示" class="headerlink" title="性能提示"></a>性能提示</h3><ul>
<li><code>GROUP BY</code> 常用 Hash Aggregate 或 Sort+Aggregate，可利用合适索引或并行聚合提升性能。  </li>
<li>窗口函数通常需要对 <code>PARTITION BY</code>&#x2F;<code>ORDER BY</code> 列进行排序；对于大表，排序开销与内存（work_mem）有关。  </li>
<li>如果想在窗口内做累积（running sum），可以考虑先按 partition&#x2F;order 排序再使用 <code>ROWS</code> 窗口框架来提高可预测性。</li>
</ul>
<hr>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DBA/" rel="tag">DBA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Postgre/" rel="tag">Postgre</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80/" rel="tag">数据库语言</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2025/10/24/%E6%85%A2%E6%9F%A5%E8%AF%A2/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            慢查询
          
        </div>
      </a>
    
    
      <a href="/2025/10/21/PostgreSQL%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">PostgreSQL中的进程和内存架构</div>
      </a>
    
  </nav>

  
   
  
   
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023-2025
        <i class="ri-heart-fill heart_icon"></i> Hexo
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/smile-circle-side.svg" alt="24stage"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2023/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>